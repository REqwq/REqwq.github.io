{"posts":[{"title":"【数论】FFT 的原理及 NTT","content":"1. 前言 说起 FFT，本人曾于大概一年前写过一篇相关的文章，但限于本人语文水平、理解程度等问题后来便废弃掉了，于是现在重新写一篇理解较为透彻的文章作为补漏。具体来说，我会采取与之前不同的介绍顺序和角度，用较易理解的语言表述。 2. 多项式基础 2.1 定义 ∘\\circ∘ 定义 nnn 次多项式 F(x)=xn+xn−1+⋯+x+1F(x)=x^n+x^{n-1}+\\cdots+x+1F(x)=xn+xn−1+⋯+x+1，您也可以把它理解成函数，表示多项式和函数时有时将后面的括号省去留下大写字母。 ∘\\circ∘ 定义 deg⁡F\\deg{F}degF 表示多项式的度，即最高次项的次数，有 deg⁡F=n\\deg{F}=ndegF=n ∘\\circ∘ 定义 F[i]F[i]F[i] 表示多项式 F(x)F(x)F(x) 第 iii 次项的系数，则有 F(x)=∑i=0nF[i]xiF(x)=\\sum_{i=0}^{n}F[i]x^iF(x)=∑i=0n​F[i]xi 2.2 卷积 令 ⊕\\oplus⊕ 为某种运算，有多项式 A(x)A(x)A(x) 和 B(x)B(x)B(x)，则它们在运算 ⊕\\oplus⊕ 下的卷积 C(x)=A(x)⊕B(x)⇒C[k]=∑i⊕j=kA[i]×B[j]C(x)=A(x)\\oplus B(x) \\Rightarrow C[k]=\\sum\\limits_{i\\oplus j=k}A[i]\\times B[j] C(x)=A(x)⊕B(x)⇒C[k]=i⊕j=k∑​A[i]×B[j] 显然，多项式乘法就是加法卷积（类比我们之前学高精度的竖式计算可知），其中，显然有 deg⁡C=deg⁡A+deg⁡B\\deg{C}=\\deg{A}+\\deg{B}degC=degA+degB。 3. FFT 的引入 3.1 DFT 和 IDFT 了解完一些基础知识后，现在我们来进入正题：如何计算多项式乘积？ 我们日常计算两个多项式的乘积的时候通常会把它们中的每一项分别相乘，再合并同类项，如： (2x2+x+1)(x2+3x+2)=2x4+6x3+4x2+x3+3x2+2x+x2+3x+2=2x4+7x3+8x2+5x+2(2x^2+x+1)(x^2+3x+2)=2x^4+6x^3+4x^2+x^3+3x^2+2x+x^2+3x+2=2x^4+7x^3+8x^2+5x+2(2x2+x+1)(x2+3x+2)=2x4+6x3+4x2+x3+3x2+2x+x2+3x+2=2x4+7x3+8x2+5x+2 是不是头很晕？（，这样算实在是太慢了！我们考虑优化它。换一种简单的表示，令 A(x)=2x2+x+1A(x)=2x^2+x+1A(x)=2x2+x+1，B(x)=x2+3x+2B(x)=x^2+3x+2B(x)=x2+3x+2，则它们的乘积 C(x)=2x4+7x3+8x2+5x+2C(x)=2x^4+7x^3+8x^2+5x+2C(x)=2x4+7x3+8x2+5x+2。试试看能不能想到点什么？我们代入几个值到 AAA，BBB，CCC 看看： 代入 x=0x=0x=0，得 A(x)=1A(x)=1A(x)=1，B(x)=2B(x)=2B(x)=2，C(x)=2C(x)=2C(x)=2 代入 x=1x=1x=1，得 A(x)=4A(x)=4A(x)=4，B(x)=6B(x)=6B(x)=6，C(x)=24C(x)=24C(x)=24 代入 x=2x=2x=2，得 A(x)=11A(x)=11A(x)=11，B(x)=12B(x)=12B(x)=12，C(x)=132C(x)=132C(x)=132 显然，无论 xxx 取何值，都有 A(x)B(x)=C(x)A(x)B(x)=C(x)A(x)B(x)=C(x)。前面说过，一个多项式 F(x)F(x)F(x) 也可以理解成一个函数，那么对于每一个 xxx 的取值，都有一个对应的 F(x)F(x)F(x)，这些点 (x,F(x))(x,F(x))(x,F(x)) 我们称之为 F(x)F(x)F(x) 的点值表示。由初中学过的待定系数法可知，n+1n+1n+1 个点便能确定一个 nnn 次函数（多项式），于是我们又能把点值表示转化为系数表示。 我们想，如果我们能把 A(x)A(x)A(x) 和 B(x)B(x)B(x) 快速地转化为点值表示，在 O(n)O(n)O(n) 时间内求出 C(x)C(x)C(x) 的点值表示，再快速地将其转化为系数表示，岂不美哉？ 于是我们称将系数表示转化为点值表示的算法为 DFT（离散傅里叶变换，Discrete Fourier Transform），将点值表示转化为系数表示的算法为 IDFT （离散傅里叶逆变换，Inverse Discrete Fourier Transform），DFT 的过程我们会优化成 FFT（快速傅里叶变换，Fast Fourier Transform），IDFT 的过程我们会优化成 IFFT（快速傅里叶逆变换，Inverse Fast Fourier Transform）。IDFT 这个算法我们会直接在后文 FFT 部分引出，下面我们讲讲 DFT。 3.2 DFT 的优化 在后面的文章中，始终假定 deg⁡A+deg⁡B=deg⁡C=n−1\\deg{A}+\\deg{B}=\\deg{C}=n-1degA+degB=degC=n−1 且 n=2kn=2^kn=2k（kkk 为任意自然数）。 也就是说我们需要找到 xxx 的 nnn 个取值（我们尽量取 222 的幂是为了方便后面的运算）并快速计算出对应的 A(x)A(x)A(x) 和 B(x)B(x)B(x) 的值。问题就出在这，我们不可能枚举 nnn 个取值并计算，这样的复杂度是 O(n2)O(n^2)O(n2) 的，我们落入窠臼，还不如直接暴力卷积呢。于是我们有一个思考方向：怎样取值能使计算量减少呢？如果这个函数是有对称性的，我们枚举一个取值，根据对称性不就可以直接得出对称点的所在的函数值了嘛！于是翻翻百度，找到了函数的奇偶性这个知识点： 简单来说，若一个函数 F(x)F(x)F(x)，满足 F(x)=F(−x)F(x)=F(-x)F(x)=F(−x)，则称这个函数为偶函数；若满足 F(x)=−F(−x)F(x)=-F(-x)F(x)=−F(−x)，则称这个函数为 奇函数。可以看出，偶函数关于 y 轴 对称，奇函数关于 原点 对称，两个奇（或偶）函数的和（或积）仍然是一个奇（或偶）函数。例如 F(x)=x2F(x)=x^2F(x)=x2 是偶函数，F(x)=2x4+3x2F(x)=2x^4+3x^2F(x)=2x4+3x2 是偶函数，F(x)=x3F(x)=x^3F(x)=x3 是个奇函数。 于是我们要求 nnn 个 xxx 对应的 A(x)A(x)A(x) 的值，考虑将 A(x)A(x)A(x) 化成以下式子: A(x)=A[0]+A[1]x+A[2]x2+...+A[n−1]xn−1=(A[0]+A[2]x2+...+A[n−2]xn−2)+(A[1]x+A[3]x3+...+A[n−1]xn−1)=(A[0]+A[2]x2+...+A[n−2]xn−2)+x(A[1]+A[3]x2+...+A[n−2]xn−2)\\begin{aligned}A(x)&amp;=A[0]+A[1]x+A[2]x^2+...+A[n-1]x^{n-1}\\\\&amp;=(A[0]+A[2]x^2+...+A[n-2]x^{n-2})+(A[1]x+A[3]x^3+...+A[n-1]x^{n-1})\\\\&amp;=(A[0]+A[2]x^2+...+A[n-2]x^{n-2})+x(A[1]+A[3]x^2+...+A[n-2]x^{n-2})\\end{aligned} A(x)​=A[0]+A[1]x+A[2]x2+...+A[n−1]xn−1=(A[0]+A[2]x2+...+A[n−2]xn−2)+(A[1]x+A[3]x3+...+A[n−1]xn−1)=(A[0]+A[2]x2+...+A[n−2]xn−2)+x(A[1]+A[3]x2+...+A[n−2]xn−2)​ 也就是说，我们将每一项按次数的奇偶提出来，化成最后的样子，我们发现两边括号里都是偶函数，我们用字母表示出来，左边的式子为 A1(x2)A1(x^2)A1(x2)，右边的式子为 A2(x2)A2(x^2)A2(x2)，则有 A(x)=A1(x2)+xA2(x2)A(x)=A1(x^2)+x A2(x^2)A(x)=A1(x2)+xA2(x2)，那我们根据偶函数的对称性可以得出 A(−x)=A1(x2)−xA2(x2)A(-x)=A1(x^2)-x A2(x^2)A(−x)=A1(x2)−xA2(x2)。 哇塞！我们这样只用算一半的取值就行了欸，而且 A1A1A1 和 A2A2A2 都变成原来的一半规模，我们把这两个函数再继续这样递归下去，那总时间复杂度就是 T(n)=2T(n2)=O(nlog⁡n)T(n)=2T(\\frac{n}{2})=O(n\\log n)T(n)=2T(2n​)=O(nlogn) 了！.................诶？感觉哪里怪怪的？ 我们要利用偶函数的对称性进行计算，那么我们取的这些 xxx 值则作为一对对相反数存在，即便在缩小规模后也是，但是，A(x)=A1(x2)+x×A2(x2)A(x)=A1(x^2)+x\\times A2(x^2)A(x)=A1(x2)+x×A2(x2) 中，A1A1A1 和 A2A2A2 的 xxx 值都是平方啊， 怎么会是相反数呢？ 当然可以，什么样的一组数不断平方后每两个仍是相反数呢？聪明的科学家们把目光投向了一个神奇的领域——复数。 我们有 12=11^2=112=1，i2=−1i^2=-1i2=−1。那么对于 n=4n=4n=4 的时候，我们的 xxx 值可以取 111、−1-1−1、iii 和 −i-i−i，递归过程如下： 1 -1 i -i →\\rightarrow→ 1 -1 →\\rightarrow→ 1 具体地，找出这些确切的取值实质上就是求解 xn=1x^n=1xn=1 的所有根，于是我们引入了一个有趣的东西—— nnn 次单位根。 3.3 nnn 次单位根的性质 我们知道，对于一个复数 z=a+biz=a+biz=a+bi，其乘法运算为模长相乘，幅角相加，既然求解复数意义下的 xn=1x^n=1xn=1 即 zn=1z^n=1zn=1，那么容易发现其模长始终为 111 且俯角为 360°n\\frac{360\\degree}{n}n360°​ ，我们称这样的 zzz 为 nnn 次单位根，记作 ωn\\omega_nωn​。那么ωn\\omega_nωn​、ωn2\\omega_n^2ωn2​、⋯\\cdots⋯、ωnn−1\\omega_n^{n-1}ωnn−1​、ωnn(=ωn0)\\omega_n^n(=\\omega_n^0)ωnn​(=ωn0​) 正好将复平面的单位圆平分成了 nnn 等份，如图： ∘\\circ∘ 引理：ωn=cos⁡θ+isin⁡θ=eiθ\\omega_n=\\cos\\theta+i\\sin\\theta=e^{i\\theta}ωn​=cosθ+isinθ=eiθ 后半部分是欧拉公式，我们证明下前半部分 因为模长为 111，幅角为 θ\\thetaθ，显然其横坐标为 cos⁡θ\\cos\\thetacosθ，纵坐标为 sin⁡θ\\sin\\thetasinθ，代入到复平面内就得到 ωn=cos⁡θ+isin⁡θ\\omega_n=\\cos\\theta+i\\sin\\thetaωn​=cosθ+isinθ。对于 ωnk：1≤k≤n\\omega_n^k：1\\le k\\le nωnk​：1≤k≤n，有 θ=2πkn\\theta=\\frac{2\\pi k}{n}θ=n2πk​，则有 ωnk=cos⁡2πkn+isin⁡2πkn=ei2πkn\\omega_n^k=\\cos\\frac{2\\pi k}{n}+i\\sin\\frac{2\\pi k}{n}=e^{i\\frac{2\\pi k}{n}}ωnk​=cosn2πk​+isinn2πk​=ein2πk​。 ∘\\circ∘ 引理：ω2n2k=ωnk\\omega_{2n}^{2k}=\\omega_n^kω2n2k​=ωnk​（折半引理） 证明： ω2n2k=ei2π×2k2n=ei2πkn=ωnk\\omega_{2n}^{2k}=e^{i\\frac{2\\pi\\times 2k}{2n}}=e^{i\\frac{2\\pi k}{n}}=\\omega_n^k ω2n2k​=ei2n2π×2k​=ein2πk​=ωnk​ ∘\\circ∘ 引理：ωnk+n2=−ωnk：1≤k≤n2\\omega_n^{k+\\frac{n}{2}}=-\\omega_n^k：1\\le k\\le \\frac{n}{2}ωnk+2n​​=−ωnk​：1≤k≤2n​（消去引理） 证明： ωnk+n2=ωnk×ωnn2=−ωnk\\omega_n^{k+\\frac{n}{2}}=\\omega_n^k\\times \\omega_n^{\\frac{n}{2}}=-\\omega_n^k ωnk+2n​​=ωnk​×ωn2n​​=−ωnk​ 其中 ωnn2\\omega_n^{\\frac{n}{2}}ωn2n​​ 相当于 ωn0\\omega_n^0ωn0​ 绕逆时针旋转 180°180\\degree180°，结合图像可知 ωnn2=−1\\omega_n^{\\frac{n}{2}}=-1ωn2n​​=−1。所以根据引理可知 ωnk+n2和ωnk\\omega_n^{k+\\frac{n}{2}} 和 \\omega_n^kωnk+2n​​和ωnk​ 互为相反数。 所以我们回到原来的递归式，A(x)=A1(x2)+xA2(x2)A(x)=A1(x^2)+x A2(x^2)A(x)=A1(x2)+xA2(x2)，A(−x)=A1(x2)−xA2(x2)A(-x)=A1(x^2)-x A2(x^2)A(−x)=A1(x2)−xA2(x2)，代入 x=ωnk(1≤k≤n2)x=\\omega_n^k(1\\le k\\le \\frac{n}{2})x=ωnk​(1≤k≤2n​)，得 A(ωnk)=A1(ωn2k)+ωnkA2(ωn2k)⇒A(ωnk)=A1(ωn2k)+ωnkA2(ωn2k)A(\\omega_n^k)=A1(\\omega_n^{2k})+\\omega_n^k A2(\\omega_n^{2k})\\Rightarrow A(\\omega_n^k)=A1(\\omega_{\\frac{n}{2}}^k)+\\omega_n^k A2(\\omega_{\\frac{n}{2}}^k) A(ωnk​)=A1(ωn2k​)+ωnk​A2(ωn2k​)⇒A(ωnk​)=A1(ω2n​k​)+ωnk​A2(ω2n​k​) A(−ωnk)=A1(ωn2k)−ωnkA2(ωn2k)⇒A(ωnk+n2)=A1(ωn2k)−ωnkA2(ωn2k)A(-\\omega_n^k)=A1(\\omega_n^{2k})-\\omega_n^k A2(\\omega_n^{2k})\\Rightarrow A(\\omega_n^{k+\\frac{n}{2}})=A1(\\omega_{\\frac{n}{2}}^k)-\\omega_n^k A2(\\omega_{\\frac{n}{2}}^k) A(−ωnk​)=A1(ωn2k​)−ωnk​A2(ωn2k​)⇒A(ωnk+2n​​)=A1(ω2n​k​)−ωnk​A2(ω2n​k​) 这样我们就能够正常地进行递归啦！这样加速后的 DFT 我们就叫它 FFT。 4. FFT 的实现 4.1 从递归到递推 根据上面我们可以得出下面的递归过程： 将整个多项式按次数的奇偶性分成两个多项式，并对这两个多项式重复划分直到只有一项。 回溯并合并 由此我们可以写出这样的代码： void FFT(Complex *A,int n){ // Complex 是手写的复数类,其中包含实部和虚部两个元素 if(n==1)return; int mid=n&gt;&gt;1; Complex A1[N],A2[N]; for(int i=0;i&lt;mid;++i){ A1[i]=A[i&lt;&lt;1]; A2[i]=A[(i&lt;&lt;1)|1]; } FFT(A1,mid),FFT(A2,mid); Complex wn=Complex(cos(PI/mid),sin(PI/mid)),w=Complex(1,0);//初始化单位根 for(int i=0;i&lt;mid;++i){// 进行合并 A[i]=A1[i]+w*A2[i]; A[i+mid]=A1[i]-w*A2[i]; w=w*wn; } return; } 可尽管是 O(nlog⁡n)O(n\\log n)O(nlogn) 的复杂度，递归带来的堆栈以及动态开空间等还是吃不消，能不能变递归为迭代呢？ 我们发现，变递归为迭代的瓶颈在于，如何快速地将多项式划分，得到最终的序列，然后逐个部分合并？形象地说，递归的思路是个正的二叉树，而迭代的思路是个倒的二叉树，我们的问题是，如何得到迭代的初始状态？ 考虑找一下规律，以下是 n=8n=8n=8 时每一项的编号序列以及划分后的序列： 0 1 2 3 4 5 6 7 -&gt; 0 4 2 6 1 3 5 7 看不太出来？换成二进制试试： 000 001 010 011 100 110 101 111 -&gt; 000 100 010 110 001 011 101 111 发现了什么？划分后的序列每一项实质上就是原序列每一项的二进制反转！ 考虑递推求出每一个数的二进制反转（也称位逆序置换，Bit Reverse），定义 revirev_irevi​ 表示 iii 的二进制反转后的数，有 revrevi=irev_{rev_i}=irevrevi​​=i。因为 revi2rev_{\\frac{i}{2}}rev2i​​ 已知，所以我们知道 iii 二进制除第一位的反转，我们只需确定反转后的最高位即可，将 revi2rev_{\\frac{i}{2}}rev2i​​ 右移一位（因为 i2\\frac{i}{2}2i​ 反转后最高位移到最低位多占了一位），补上最高位，就得到 iii 的二进制反转了，代码： for(int i=0;i&lt;n;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;len-1); // len 是 n 的二进制位数 for(int i=0;i&lt;n;++i)if(i&lt;rev[i])swap(A[i],A[rev[i]]);// 处理 现在考虑递归的问题，我们要做的就是： 枚举长度 对每一块进行计算合并 得到如下代码： void FFT(Complex *A,int n){ for(int mid=1;mid&lt;n;mid&lt;&lt;=1){ // 枚举每次合并区间长的一半 Complex wn=Complex(cos(PI/mid),op*sin(PI/mid)); for(int len=mid&lt;&lt;1,now=0;now&lt;lim;now+=len){ // now 为每一块的起始位置 Complex w=Complex(1,0); for(int j=0;j&lt;mid;++j,w=w*wn){ Complex x=A[now+j],y=w*A[now+j+mid]; // 此时的 A 为未合并的状态 A[now+j]=x+y; A[now+j+mid]=x-y; } } } return; } 这个 xxx 和 yyy 加减的过程有个有意思的名字：“蝴蝶变换“。 4.2 代码流程梳理 首先，我们进行二进制反转的操作，然后通过蝴蝶变换逐个合并，最终得到点值表示。如图： 4.3 IFFT 我们解决了系数转点值的过程，现在我们要来考虑点值转系数的过程了。 已知 A(ωni)×B(ωni)=C(ωni)=∑j=0n−1ωnijcjA(\\omega^i_n)\\times B(\\omega^i_n)=C(\\omega^i_n)=\\sum\\limits_{j=0}^{n-1}\\omega^{ij}_nc_jA(ωni​)×B(ωni​)=C(ωni​)=j=0∑n−1​ωnij​cj​，求 ci=?c_i=?ci​=? 发现可以写成矩阵相乘的形式（此处将 C(ωni)C(\\omega^i_n)C(ωni​) 简写成 CiC_iCi​） [C0C1C2C3⋮Cn−1]=[1111⋯11ωn1ωn2ωn3⋯ωnn−11ωn2ωn4ωn6⋯ωn2(n−1)1ωn3ωn6ωn9⋯ωn3(n−1)⋮⋮⋮⋮⋱⋮1ωnn−1ωn2(n−1)ωn3(n−1)⋯ωn(n−1)2][c0c1c2c3⋮cn−1]\\begin{bmatrix}C_0\\\\C_1\\\\C_2\\\\C_3\\\\\\vdots\\\\C_{n-1}\\end{bmatrix}=\\begin{bmatrix}1&amp;1&amp;1&amp;1&amp;\\cdots&amp;1\\\\1&amp;\\omega_n^1&amp;\\omega_n^2&amp;\\omega_n^3&amp;\\cdots&amp;\\omega_n^{n-1}\\\\1&amp;\\omega_n^2&amp;\\omega_n^4&amp;\\omega_n^6&amp;\\cdots&amp;\\omega_n^{2(n-1)}\\\\1&amp;\\omega_n^3&amp;\\omega_n^6&amp;\\omega_n^9&amp;\\cdots&amp;\\omega_n^{3(n-1)}\\\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\1&amp;\\omega_n^{n-1}&amp;\\omega_n^{2(n-1)}&amp;\\omega_n^{3(n-1)}&amp;\\cdots&amp;\\omega_n^{(n-1)^2}\\end{bmatrix}\\begin{bmatrix}c_0\\\\c_1\\\\c_2\\\\c_3\\\\\\vdots\\\\c_{n-1}\\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎡​C0​C1​C2​C3​⋮Cn−1​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​1111⋮1​1ωn1​ωn2​ωn3​⋮ωnn−1​​1ωn2​ωn4​ωn6​⋮ωn2(n−1)​​1ωn3​ωn6​ωn9​⋮ωn3(n−1)​​⋯⋯⋯⋯⋱⋯​1ωnn−1​ωn2(n−1)​ωn3(n−1)​⋮ωn(n−1)2​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​c0​c1​c2​c3​⋮cn−1​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​ 我们要求 cic_ici​ 的矩阵就将左右两边的等式乘上中间矩阵的逆就行了，我们有以下结论： cj=1n∑i=0n−1ωn−ijCic_j=\\frac{1}{n}\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ij}C_i cj​=n1​i=0∑n−1​ωn−ij​Ci​ 浅证一下： cj=1n∑i=0n−1ωn−ijCi=1n∑i=0n−1ωn−ij(∑k=0n−1ωnikck)=1n∑k=0n−1ck∑i=0n−1ωnikωn−ij=1n∑k=0n−1ck∑i=0n−1ωni(k−j)\\begin{aligned}c_j&amp;=\\frac{1}{n}\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ij}C_i\\\\&amp;=\\frac{1}{n}\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ij}(\\sum\\limits_{k=0}^{n-1}\\omega^{ik}_nc_k)\\\\&amp;=\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}c_k\\sum\\limits_{i=0}^{n-1}\\omega^{ik}_n\\omega_n^{-ij}\\\\&amp;=\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}c_k\\sum\\limits_{i=0}^{n-1}\\omega^{i(k-j)}_n\\end{aligned} cj​​=n1​i=0∑n−1​ωn−ij​Ci​=n1​i=0∑n−1​ωn−ij​(k=0∑n−1​ωnik​ck​)=n1​k=0∑n−1​ck​i=0∑n−1​ωnik​ωn−ij​=n1​k=0∑n−1​ck​i=0∑n−1​ωni(k−j)​​ 考虑 ∑i=0n−1ωni(k−j)\\sum\\limits_{i=0}^{n-1}\\omega^{i(k-j)}_ni=0∑n−1​ωni(k−j)​ 的取值，当 k=jk=jk=j 时 ∑i=0n−1ωni(k−j)=∑i=0n−1ωn0=n\\sum\\limits_{i=0}^{n-1}\\omega^{i(k-j)}_n=\\sum\\limits_{i=0}^{n-1}\\omega^0_n=n i=0∑n−1​ωni(k−j)​=i=0∑n−1​ωn0​=n 当 k=jk\\not ={j}k​=j 时，代入等比数列求和 ∑i=0n−1ωni(k−j)=∑i=0n−1(ωnk−j)i=(ωnk−j)n−1ωnk−j−1=(ωnn)k−j−1ωnk−j−1=1−1ωnk−j=0\\sum\\limits_{i=0}^{n-1}\\omega^{i(k-j)}_n=\\sum\\limits _{i=0}^{n-1}(\\omega_n^{k-j})^{i}=\\dfrac{(\\omega_n^{k-j})^n-1}{\\omega_n^{k-j}-1}=\\dfrac{(\\omega_n^n)^{k-j}-1}{\\omega_n^{k-j}-1}=\\dfrac{1-1}{\\omega_n^{k-j}}=0 i=0∑n−1​ωni(k−j)​=i=0∑n−1​(ωnk−j​)i=ωnk−j​−1(ωnk−j​)n−1​=ωnk−j​−1(ωnn​)k−j−1​=ωnk−j​1−1​=0 所以得 cj=1n∑k=0n−1ck∑i=0n−1ωni(k−j)=1n×ncj=cj\\begin{aligned}c_j&amp;=\\frac{1}{n}\\sum\\limits_{k=0}^{n-1}c_k\\sum\\limits_{i=0}^{n-1}\\omega^{i(k-j)}_n\\\\&amp;=\\frac{1}{n}\\times nc_j\\\\&amp;=c_j\\end{aligned} cj​​=n1​k=0∑n−1​ck​i=0∑n−1​ωni(k−j)​=n1​×ncj​=cj​​ 由此，我们可以直接用上面 FFT 的函数做 IFFT 运算，只需把 ωn\\omega_nωn​ 变为 ωn−1\\omega_n^{-1}ωn−1​，最后除以 nnn 就行了。 4.4 完整实现 ∘\\circ∘ 例题：Luogu P3803 【模板】多项式乘法（FFT） 提交记录（注意 double 的精度，输出时要四舍五入） ∙\\bullet∙ 三步变两步优化 考虑复数 z=a+biz=a+biz=a+bi，有 z2=(a+bi)2=a2−b2+2abiz^2=(a+bi)^2=a^2-b^2+2abiz2=(a+bi)2=a2−b2+2abi 发现了什么？我们把输入的多项式 BBB 放在 AAA 的虚部上，求出 A2A^2A2 就行了。 提交记录（快了 1s） 5. 升级：从 FFT 到 NTT FTT 虽好，但其单位根为浮点数的限制太大，容易引发精度问题。考虑到单位根只是一个用来加速运算的东西，且大多的计数问题都需要取模，那我们能否在模意义下找到一个单位根的替代品呢？ 答案是还真有（废话，不然我写这个干嘛），我们叫它 NTT（快速数论变换，Number Theory Transform）。 5.1 原根 对于 a∈Za\\in \\mathbb{Z}a∈Z，p∈N+p\\in\\mathbb{N}^+p∈N+，gcd⁡(a,p)=1\\gcd(a,p)=1gcd(a,p)=1，满足 an≡1(modp)a^n\\equiv 1\\pmod pan≡1(modp) 的最小的正整数 nnn，我们称它为“aaa 模 ppp 的阶”，记作 δp(a)\\delta_p(a)δp​(a) 或 ord⁡p(a)\\operatorname{ord}_p(a)ordp​(a)。显然由欧拉定理可知 nnn 的上界为 φ(p)\\varphi(p)φ(p)。 若 g∈Zg\\in\\mathbb{Z}g∈Z 满足 δp(g)=φ(p)\\delta_p(g)=\\varphi(p)δp​(g)=φ(p) ，即达到上界，那我们称 ggg 是模 ppp 意义下的原根。下面所述的 ggg 都代表原根。 ∘\\circ∘ 引理：g1,g2,⋯ ,gδp(g)g^1,g^2,\\cdots,g^{\\delta_p(g)}g1,g2,⋯,gδp​(g) 在模 ppp 意义下两两不同余。 证明：若存在 i=ji\\not=ji​=j，且 gi≡gj(modp)g^i\\equiv g^j\\pmod pgi≡gj(modp)，那么有 g∣i−j∣≡1(modp)g^{|i-j|}\\equiv 1\\pmod pg∣i−j∣≡1(modp)，可 1≤∣i−j∣≤δp(g)1\\leq|i-j|\\leq \\delta_p(g)1≤∣i−j∣≤δp​(g)，与阶的最小性矛盾，故引理成立。 这也说明了为什么能用原根的原因之一：我们使用单位根的原因之一，就是因为它们在 nnn 次下取值各不相同。但 nnn 显然不一定等于 p−1p-1p−1，那么我们肯定要想办法利用原根构造一组取值。 5.2 原根的使用 对于质数 p=qn+1(n=2k)p=qn+1(n=2^k)p=qn+1(n=2k)(一般给的质数都满足这个)，则其原根 ggg 满足 δp(g)=qn\\delta_p(g)=qnδp​(g)=qn，那么我们令 gn=gq=gp−1ng_n=g^q=g^{\\frac{p-1}{n}}gn​=gq=gnp−1​ 就可以构造出等价于 ωn\\omega_nωn​ 的值啦。 诶诶诶等等，为什么啊？ 要证明 gng_ngn​ 和 ωn\\omega_nωn​ 等价，我们得要证明 gng_ngn​ 跟 ωn\\omega_nωn​ 有一样的性质，那么回顾一下，ωn\\omega_nωn​ 有哪些性质呢？ ∘\\circ∘ 折半引理：ω2n2k=ωnk\\omega_{2n}^{2k}=\\omega_n^kω2n2k​=ωnk​ 证明： g2n2k=(gp−12n)2k=(gp−1n)k=gnkg_{2n}^{2k}=(g^{\\frac{p-1}{2n}})^{2k}=(g^{\\frac{p-1}{n}})^k=g_n^k g2n2k​=(g2np−1​)2k=(gnp−1​)k=gnk​ 所以，g2n2k≡gnk(modp)g_{2n}^{2k}\\equiv g_n^k\\pmod pg2n2k​≡gnk​(modp)。 ∘\\circ∘ ωnn2=−1\\omega_n^{\\frac{n}{2}}=-1ωn2n​​=−1 证明： gnn2=(gp−1n)n2=gp−12g_n^{\\frac{n}{2}}=(g^{\\frac{p-1}{n}})^{\\frac{n}{2}}=g^{\\frac{p-1}{2}} gn2n​​=(gnp−1​)2n​=g2p−1​ 我们有 (gp−12)2=gp−1≡1(modp)(g^{\\frac{p-1}{2}})^2=g^{p-1}\\equiv 1\\pmod p (g2p−1​)2=gp−1≡1(modp) 若 gp−12≡1(modp)g^{\\frac{p-1}{2}}\\equiv 1\\pmod pg2p−1​≡1(modp)，则与阶的最小性矛盾，那么只能有 gp−12≡−1(modp)g^{\\frac{p-1}{2}}\\equiv -1\\pmod pg2p−1​≡−1(modp)。 所以，gnn2≡−1(modp)g_n^{\\frac{n}{2}}\\equiv -1\\pmod pgn2n​​≡−1(modp)。 ∘\\circ∘ 消去引理： ωnk+n2=−ωnk\\omega_n^{k+\\frac{n}{2}}=-\\omega_n^kωnk+2n​​=−ωnk​ 证明： gnk+n2=gnk×gnn2≡−gnk(modp)g_n^{k+\\frac{n}{2}}=g_n^k\\times g_n^{\\frac{n}{2}}\\equiv-g_n^k\\pmod p gnk+2n​​=gnk​×gn2n​​≡−gnk​(modp) 所以，gnk+n2≡−gnk(modp)g_n^{k+\\frac{n}{2}}\\equiv-g_n^k\\pmod pgnk+2n​​≡−gnk​(modp) 由此，我们只需要把所有 ωn\\omega_nωn​ 都换成模 ppp 意义下的 gng_ngn​ 就好啦！ 5.3 NTT 的实现 还是模板题 Luogu P3803 【模板】多项式乘法（FFT） 提交记录（注意逆变换中需要逆元） 比三步变两步优化后的 FFT 还要快一些，因为我们无需常数极大的复数计算，以及一些三角函数计算，实际上还可以再优化。 5.4 附：原根表 一般常用的质数及其原根有： p=998244353=7×17×223+1，g=3p=998244353=7\\times 17\\times 2^{23}+1，g=3 p=998244353=7×17×223+1，g=3 p=1004535809=479×221+1，g=3p=1004535809=479\\times 2^{21}+1，g=3 p=1004535809=479×221+1，g=3 6. 后记 &amp; 参考资料 简单地写了一下，就当作复习和学习新的东西，如果有什么错漏还请提出，我会及时修改。 ∘\\circ∘ FFT 参考资料： command_block：傅里叶变换(FFT)学习笔记 繁凡さん：【学习笔记】超简单的快速傅里叶变换（FFT）（含全套证明） OI Wiki：快速傅里叶变换 Bilibili 视频：快速傅里叶变换(FFT)——有史以来最巧妙的算法？ Bilibili 视频：具体学习并实现快速傅里叶变换（FFT） ∘\\circ∘ NTT 参考资料： command_block：NTT与多项式全家桶 繁凡さん：【学习笔记】超简单的快速数论变换（NTT）（FFT的优化）（含全套证明） OI Wiki：原根 OI Wiki：快速数论变换 ","link":"https://reqwq.github.io/post/fft-de-yuan-li-ji-ntt/"},{"title":"【DS】浅谈树状数组倍增","content":"无意中看到的一个小 trick，便记录下来。 引入 给您一个数组，您需要实现以下操作和询问： ∙\\bullet∙ 插入一个数字 xxx。 ∙\\bullet∙ 查询排名为 kkk 的数 xxx。 显然我们有权值线段树或者平衡树的做法。 但是我偏不（傲娇），我们来考虑树状数组怎么做。 树状数组倍增 定义： nnn：数组大小 aia_iai​：离散化后第 iii 个数出现的次数 cic_ici​：树状数组 思路 插入一个数字就是单点修改啦，考虑询问。 写过平衡树模板的我们肯定知道，一个数 xxx （离散化后）的排名就是比 xxx 小的数的个数 +1+1+1，即 rank⁡(x)=(∑i=1x−1ai)+1\\operatorname{rank}(x)=(\\sum\\limits^{x-1}_{i=1}a_i)+1rank(x)=(i=1∑x−1​ai​)+1。那么反过来，要查询排名为 kkk 的数 xxx， 它的位置就是 max⁡rank⁡(x)≤kx\\max\\limits_{\\operatorname{rank}(x)\\leq k}xrank(x)≤kmax​x，我们把它展开来看，即 (∑i=1x−1ai)+1≤k(\\sum^{x-1}_{i=1}a_i)+1\\leq k (i=1∑x−1​ai​)+1≤k (∑i=1x−1ai)≤k−1(\\sum^{x-1}_{i=1}a_i)\\leq k-1 (i=1∑x−1​ai​)≤k−1 左半部分可以直接树状数组求，我们枚举一个 rrr，那么我们枚举到的符合条件的最大的 rrr 就是 (x−1)(x-1)(x−1)，答案即为 r+1r+1r+1。 为什么不能直接 ≤k\\leq k≤k？因为有的数可能不存在，例如 '1 0 1 0 0'，我们查询排名为 222 的数，按正确的方法答案就是 333，如果直接 ≤k\\leq k≤k 则输出为 555。不过有的时候我们会需要这样做，在后文会讲到。 如何求 rrr？显然不能 O(nlog⁡n)O(n\\log{n})O(nlogn)，那有没有什么方法能降低枚举复杂度至 O(log⁡n)O(\\log{n})O(logn) 呢？ 废话，看标题不就知道了 具体实现 引理 ci=∑j=i−lowbit(i)+1iaic_i=\\sum\\limits^{i}_{j=i-lowbit(i)+1}a_i ci​=j=i−lowbit(i)+1∑i​ai​ 由树状数组的定义知显然。 倍增 我们能不能通过枚举跳 2log⁡n,2log⁡n−1,...,21,202^{\\log n}, 2^{\\log n-1}, ... , 2^1, 2^02logn,2logn−1,...,21,20 的距离去找呢？ 代码如下： int kth(int k){ int r=0,tot=0,x,y; for(int i=log(值域);~i;--i){ x=r+(1&lt;&lt;i);if(x&gt;值域)continue; y=tot+c[x]; if(y&lt;k)r=x,tot=y; } return r+1; } 这里每次 tot←tot+cr+2itot\\leftarrow tot+c_{r+2^i}tot←tot+cr+2i​ 是什么意思呢？根据上面得引理可知，加上 cr+2ic_{r+2^i}cr+2i​ 相当于加上 ∑j=rr+2iai\\sum\\limits^{r+2^i}_{j=r}a_ij=r∑r+2i​ai​，即不断地向后拓展，到最后 tottottot 的值即为 ∑i=1rai\\sum\\limits^{r}_{i=1}a_ii=1∑r​ai​。 为什么这样就能满足 rrr 最大？因为我们是从大到小枚举的。 优点 &amp; 缺点 ∙\\bullet∙ 优点：常数小，码量小，容易记。 ∙\\bullet∙ 缺点：需要离线。 用途 一般用于优化部分需要求 kkk 小的操作，不作为主要算法。 例题 ∘\\circ∘ CF786C Till I Collapse 将 nnn 个数划分成 mmm 段使得每中不同数字的个数 ≤k\\le k≤k. 对于每个 kkk 满足 1≤k≤n1\\le k \\le n1≤k≤n 求出最小的 mmm。 考虑对于一个 kkk 怎么求。我们贪心地尽可能分最大的段，使得段内不同数字个数不大于 kkk，询问区间不同数字的个数，就是数颜色嘛，我们想到 HH 的项链 的做法，但是有点不同：对于 HH 的项链里，我们知道右端点的位置，于是对于每一个数字的贡献都放到尽可能右边；但是这道题里面我们并不止都右端点（而是要求它），所以对于每一个枚举到的左端点的数字，（如果它对答案有贡献）我们计算贡献之后将它的贡献放到下一个出现的位置上就行了。每一次分段询问最远能到达的右端点即可，我们有这样的代码： void add(int x,int v){while(x&lt;=n)c[x]+=v,x+=lb;} int kth(int k){ int r=0,tot=0,x,y; ++k;//注意这里 k 要加一 for(int i=18;~i;--i){ x=r+(1&lt;&lt;i);if(x&gt;n)continue; y=tot+c[x]; if(y&lt;k)r=x,tot=y; } return r;//注意这里 r 不用加一 } for(int l=1,r=0;l&lt;=n;++l){ if(l==r+1)++ans,r=kth(l); add(l,-1),add(nxt[l],1); } 为什么 kkk 要加一而 rrr 不用加一？因为我们计算数字个数的时候，中间可能有一串 0，例如：1 1 0 1 0 0 1 0，k=3。如果是之前的代码的话，返回的答案是 4，而实际上能扩展到的最远的右端点是 6。我们把 kkk 加一并且 rrr 不加一就可避免此问题。 对于 111 到 nnn 的所有 kkk 怎么求？我们可以一起求啊！毕竟每个数的贡献仅在数本身，我们对于所有询问的左端点维护个优先队列，然后按照上面的方法计算答案即可。 提交记录 其他练习： ∘\\circ∘ CF1181D Irrigation ∘\\circ∘ Luogu P6619 [省选联考 2020 A/B 卷] 冰火战士 ","link":"https://reqwq.github.io/post/ds-qian-tan-shu-zhuang-shu-zu-bei-zeng/"},{"title":"【置顶】Todo List","content":" 施工中👷： 暂无 敬请期待/咕咕中🕊： DP 决策单调性小记 ","link":"https://reqwq.github.io/post/todo-list/"},{"title":"【DP 记录】AcWing 734. 能量石","content":"传送门 给你几个物品，每种选一次，求最大价值，首先想到 01 背包，但是我们遇到了一个问题： 普通的 01 背包在选择物品时是不讲求顺序的，但在这道题中，物品的选择是有顺序的（即对最优解贡献有顺序），显然 O(n!)O(n!)O(n!) 枚举排列不可取，那我们能否提前确定好顺序，再来做背包呢？ ∙ \\bullet\\;∙ 考虑从贪心解入手 对于贪心解，我们得到一组排列 a1,a2,…,ana_1,a_2,\\ldots,a_na1​,a2​,…,an​ ，其中任选相邻的一对 iii 和 jjj，我们将其交换位置，所得的新的解一定不增（否则就贪心地选这个顺序了），即它们的总贡献 Ei+Ej−Si×Lj≥Ei+Ej−Sj×LiE_i+E_j-S_i\\times L_j \\geq E_i+E_j-S_j\\times L_i Ei​+Ej​−Si​×Lj​≥Ei​+Ej​−Sj​×Li​ 消掉一些项，将有关 iii 的移到左边，得 SiLi≤SjLj\\frac{S_i}{L_i} \\leq \\frac{S_j}{L_j} Li​Si​​≤Lj​Sj​​ 即我们可以按照这样排序，得到最优的顺序来背包。 ∙ \\bullet\\;∙ 如何证明贪心解即为最优解？ 对于最优解的排列方式，我们可以将满足 SiLi&gt;SjLj\\frac{S_i}{L_i} &gt; \\frac{S_j}{L_j}Li​Si​​&gt;Lj​Sj​​ 的相邻两项交换，其解一定不降，所以 贪心解 ≥ 最优解。又因为，贪心解一定是合法解，所以 贪心解 ≤ 最优解，故 贪心解 = 最优解。 new trick: 邻项交换法！ 提交记录 ","link":"https://reqwq.github.io/post/dp-ji-lu-acwing-734-neng-liang-shi/"},{"title":"【图论】搜索算法学习笔记","content":"此笔记始于 2021.4.32021.4.32021.4.3，蒟蒻在 AcWingAcWingAcWing 学习搜索算法 （QAQ没有打广告啊） 不得不说，搜索和图论绝对是考场上极大概率会出的考点，之后学习图论时会增加图论学习笔记。 BFSBFSBFS 特点 求最小：这个不用说了吧 基于迭代：相比于 DFSDFSDFS 来说不会爆栈 所以当遇到一个问题同时可以用 BFSBFSBFS 和 DFSDFSDFS 求解的时候，当然是优先选择 BFSBFSBFS 。 Flood FillFlood\\ FillFlood Fill 模型 模型介绍： 所谓 FloodFillFloodFillFloodFill ，顾名思义，洪水覆盖，具体什么意思呢，可以理解成连通块问题，或是您在 MinecraftMinecraftMinecraft 的平地上放一桶水（，水不会流到障碍物，而是向四周的平地继续扩散。 Flood FillFlood\\ FillFlood Fill 不一定只是基于 BFSBFSBFS，但最好要选择 BFSBFSBFS，因为我上面说过了，DFSDFSDFS 可能会导致爆栈。 那么它有什么作用呢？它的作用就是在线性时间复杂度内找到某个点所在连通块 话不多说，上例题：P1596 [USACO10OCT]Lake Counting S DescriptionDescriptionDescription： 农夫约翰有一片 N×MN\\times MN×M 的矩形土地。 最近，由于降雨的原因，部分土地被水淹没了。 现在用一个字符矩阵来表示他的土地。 每个单元格内，如果包含雨水，则用 ”WWW” 表示，如果不含雨水，则用”.”表示。 现在，约翰想知道他的土地中形成了多少片池塘。 每组相连的积水单元格集合可以看作是一片池塘。 每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。 请你输出共有多少片池塘，即矩阵中共有多少片相连的 ”WWW” 块。 Solution:Solution:Solution: 这道题是 Flood FillFlood\\ FillFlood Fill 算法的典型应用。我们可以逐行扫描整个字符矩阵，当找到一处有水的土地，且还没有被标记（即覆盖）时，从这个点开始做 Flood FillFlood\\ FillFlood Fill ：标记其所在的整个连通块并增加答案。也可以这么说：我们在一片茫茫大海上航行，当我们发现一片新大陆时，我们把整个大陆都探索一遍，再继续寻找其他大陆，直到全世界都走了个遍。这也是 Flood FillFlood\\ FillFlood Fill 的核心思想。 是不是很简单呢，这里直接给出代码： Code:Code:Code: #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; const int N=110; typedef pair&lt;int,int&gt; p; #define mp(x,y) make_pair(x,y) #define x first #define y second int n,m,ans,f[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; bool vis[N][N]; queue&lt;p&gt;q; void bfs(int i,int j){//标记连通块操作，代码不难理解 q.push(mp(i,j)); vis[i][j]=true; while(!q.empty()){ p tmp=q.front();q.pop(); int xx,yy; for(int i=0;i&lt;8;++i){ xx=tmp.x+f[i][0],yy=tmp.y+f[i][1]; if(xx&lt;=0||xx&gt;n||yy&lt;=0||yy&gt;m||vis[xx][yy])continue; vis[xx][yy]=true; q.push(mp(xx,yy)); } } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ char t;scanf(&quot; %c&quot;,&amp;t); vis[i][j]=t=='.';//不用搜的提前标记 } } for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ if(!vis[i][j]){//如果有没发现的新大陆 ++ans;//答案增加 bfs(i,j);//标记整个连通块 } } } printf(&quot;%d&quot;,ans); return 0; } 再来看一道例题 P1457 [USACO2.1]城堡 The Castle DescriptionDescriptionDescription： 1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####---#####---#---#####---# 2 # # | # # # # # #---#####---#####---#####---# 3 # | | # # # # # #---#########---#####---#---# 4 # # | | | | # # ############################# (图 1) # = Wall | = No wall - = No wall 方向：上北下南左西右东。 如图是一个城堡的地形图。 请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大，移除一面墙能得到的最大的房间的大小，移除哪面墙可以得到面积最大的新房间。 城堡被分割成 m×nm\\times nm×n 个方格区域，每个方格区域可以有 0−40-40−4 面墙。 注意：墙体厚度忽略不计，选择最佳的墙来推倒。有多解时选最靠西的，仍然有多解时选最靠南的。同一格子北边的墙比东边的墙更优先。 Solution:Solution:Solution: 先来解释一下样例吧，如图 我们可以找出，一共有 555 个房间，最大的房间面积为 999 ，移去箭头所指的那面墙，可以使 222 个房间合为一个新房间，且比移去其他墙所形成的房间都大。 这道题难就难在输入，每一个单位的数字告诉我们这个单位的东西南北是否有墙存在。每个数字是由以下四个整数中的任意个加起来的。 1:1:1: 在西面有墙 2:2:2: 在北面有墙 4:4:4: 在东面有墙 8:8:8: 在南面有墙 即若输入是 111111，11=1+2+811=1+2+811=1+2+8，则代表这个格子西、北、东都有墙。 我们发现，代表墙的四个数都是 2k2^k2k，所以直接二进制枚举就行了，用 0,1,2,30,1,2,30,1,2,3 分别表示西、北、东、南（即 2k2^k2k 的 kkk）。 前两问很简单，房间个数就是连通块个数，最大面积也可以在 BFSBFSBFS 的时候计算，主要是后两问，我们把前后两问单独拿出来计算。 我们在前两问的 BFSBFSBFS 中可以预处理出每个点所在的连通块，和所在连通块的大小，那么回答完前两个问题后再枚举一遍整个矩阵，找到有墙且墙两边的房间不属于同一连通块的位置，比较两边连通块大小的和和当前答案即可。 ！！！注意细节——“有多解时选最靠西的，仍然有多解时选最靠南的。同一格子北边的墙比东边的墙更优先”，枚举时注意顺序。 Code:Code:Code: #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;iostream&gt; using namespace std; const int N=55; typedef pair&lt;int,int&gt; p; #define mp(x,y) make_pair(x,y) #define x first #define y second int n,m; int cnt,ans1,ans2,ansx,ansy;char direction;//连通块个数，最大面积，推掉一面墙的最大面积，墙的方位 int map[N][N],f[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//西，北，东，南（注意顺序） int vis[N][N],area[N*N];//记录所在连通块,每个连通块面积 queue&lt;p&gt; q; void bfs(int i,int j){ q.push(mp(i,j));vis[i][j]=cnt; while(!q.empty()){ p tmp=q.front();q.pop(); ++area[cnt]; for(int i=0;i&lt;4;++i){//2进制枚举 if(((map[tmp.x][tmp.y]&gt;&gt;i)&amp;1)==0){//如果没有墙（优先级害人啊QAQ） int xx=tmp.x+f[i][0],yy=tmp.y+f[i][1]; if(xx&lt;=0||xx&gt;n||yy&lt;=0||yy&gt;m||vis[xx][yy])continue; vis[xx][yy]=cnt; q.push(mp(xx,yy)); } } } } int main(){ scanf(&quot;%d%d&quot;,&amp;m,&amp;n);//注意输入是m,n for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=m;++j)scanf(&quot;%d&quot;,&amp;map[i][j]); for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ if(!vis[i][j]){ ++cnt;bfs(i,j); ans1=max(ans1,area[cnt]); } } } printf(&quot;%d\\n%d\\n&quot;,cnt,ans1); for(int j=1;j&lt;=m;++j){ for(int i=n;i;--i){//&quot;有多解时选最靠西的，仍然有多解时选最靠南的&quot; for(int k=1;k&lt;=2;++k){//枚举北、东两个方向 ,&quot;同一格子北边的墙比东边的墙更优先&quot; if((map[i][j]&gt;&gt;k)&amp;1){//如果有墙 int xx=i+f[k][0],yy=j+f[k][1]; if(xx&lt;=0||xx&gt;n||yy&lt;=0||yy&gt;m)continue; int sum=area[vis[i][j]]+area[vis[xx][yy]];//加上两个连通块的面积，相同连通块后面判断 if(vis[i][j]^vis[xx][yy]&amp;&amp;sum&gt;ans2){ ans2=sum,ansx=i,ansy=j; direction=k==1?'N':'E'; } } } } } printf(&quot;%d\\n%d %d %c&quot;,ans2,ansx,ansy,direction); return 0; } 练习： P3456 [POI2007]GRZ-Ridges and Valleys CF510B Fox And Two Dots 最短路模型 模型介绍 这名字不显而易见？不用我讲了呢。我们知道，BFSBFSBFS 有一个很好的性质，就是当所有边的权值都相等的情况下，BFSBFSBFS 第一次搜到某个点的路径就是从源点到这个点的单源最短路径。 那就上例题吧 1076. 迷宫问题 （洛谷上找不到相同的题，只好直接放了QAQ，如果有记得告诉我题号啊） Description:Description:Description: 给定一个 n×n 的二维数组，如下所示： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的 111 表示墙壁，000 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。 按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)(0,0)(0,0)，右下角坐标为 (n−1,n−1)(n-1,n-1)(n−1,n−1)。 数据保证至少存在一条从左上角走到右下角的路径。 Solution:Solution:Solution: 这用 BFSBFSBFS 显然很好写：我们可以记录一个 pre[i][j]pre[i][j]pre[i][j] 数组，这个数组是 pairpairpair 类型的，干什么用呢？记录一个点是从哪个点搜到的，最后得出答案的时候我们可以得到从终点到起点的一条路径，最后反向输出即可。 小 trick:trick:trick: 我们不妨从终点开始搜回起点，最后把路径“逆序”输出就好了啊。 Code:Code:Code: #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; const int N=1e3+10; typedef pair&lt;int,int&gt; p; #define mp(x,y) make_pair(x,y) #define x first #define y second int n,map[N][N];bool vis[N][N]; int f[4][2]={{-1,0},{1,0},{0,-1},{0,1}}; p pre[N][N]; queue&lt;p&gt; q; void bfs(){ pre[n][n].x=pre[n][n].y=0;//这个是待会输出的终止条件 q.push(mp(n,n));//从终点搜回起点 vis[n][n]=true; while(!q.empty()){ p tmp=q.front();q.pop(); for(int i=0;i&lt;4;++i){ int xx=tmp.x+f[i][0],yy=tmp.y+f[i][1]; if(xx&lt;=0||xx&gt;n||yy&lt;=0||yy&gt;n||vis[xx][yy]||map[xx][yy])continue; pre[xx][yy]=tmp;//加入路径 vis[xx][yy]=true; q.push(mp(xx,yy)); } } } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=n;++j){ scanf(&quot;%d&quot;,&amp;map[i][j]); } } bfs(); //“逆序”输出 puts(&quot;0 0&quot;); p tmp=pre[1][1]; while(tmp.x&amp;&amp;tmp.y){ printf(&quot;%d %d\\n&quot;,tmp.x-1,tmp.y-1);//由于我这里是1~n所以要-1 tmp=pre[tmp.x][tmp.y]; } return 0; } 再来看第二道例题 188. 武士风度的牛 Description:Description:Description: 农民 JohnJohnJohn 有很多牛，他想交易其中一头被 DonDonDon 称为 The KnightThe\\ KnightThe Knight 的牛。 这头牛有一个独一无二的超能力，在农场里像 KnightKnightKnight 一样地跳（就是我们熟悉的象棋中马的走法）。 虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x,yx,yx,y 的坐标图来表示。 这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The KnightThe\\ KnightThe Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。 现在你的任务是，确定 The KnightThe\\ KnightThe Knight 要想吃到草，至少需要跳多少次。 The KnightThe \\ KnightThe Knight 的位置用 KKK 来标记，障碍的位置用 ∗*∗ 来标记，草的位置用 HHH 来标记。 这里有一个地图的例子： 11 | . . . . . . . . . . 10 | . . . . * . . . . . 9 | . . . . . . . . . . 8 | . . . * . * . . . . 7 | . . . . . . . * . . 6 | . . * . . * . . . H 5 | * . . . . . . . . . 4 | . . . * . . . * . . 3 | . K . . . . . . . . 2 | . . . * . . . . . * 1 | . . * . . . . * . . 0 ---------------------- 0 1 2 3 4 5 6 7 8 9 10 The Knight 可以按照下图中的 A,B,C,D…A,B,C,D…A,B,C,D… 这条路径用 555 次跳到草的地方（有可能其它路线的长度也是 555）： 11 | . . . . . . . . . . 10 | . . . . * . . . . . 9 | . . . . . . . . . . 8 | . . . * . * . . . . 7 | . . . . . . . * . . 6 | . . * . . * . . . F&lt; 5 | * . B . . . . . . . 4 | . . . * C . . * E . 3 | .&gt;A . . . . D . . . 2 | . . . * . . . . . * 1 | . . * . . . . * . . 0 ---------------------- 0 1 2 3 4 5 6 7 8 9 10 Solution:Solution:Solution: 这道题除了行走方式不同外都相同，还记得我们上面说的性质嘛，边权相同时，一个点在 BFSBFSBFS 中第一次被搜到的路径一定就是单源最短路径，那么问题就解决啦。 Code:Code:Code: #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;queue&gt; using namespace std; const int N=200; typedef pair&lt;int,int&gt; p; #define mp(x,y) make_pair(x,y) #define x first #define y second int r,c,sx,sy,fx,fy; char map[N][N]; int cnt[N][N]; int f[8][2]={{-2,-1},{-2,1},{-1,2},{1,2},{2,-1},{2,1},{1,-2},{-1,-2}}; queue&lt;p&gt; q; void bfs(){ q.push(mp(sx,sy)); cnt[sx][sy]=1; while(!q.empty()){ p tmp=q.front();q.pop(); for(int i=0;i&lt;8;++i){ int xx=tmp.x+f[i][0],yy=tmp.y+f[i][1]; if(xx&lt;=0||xx&gt;r||yy&lt;=0||yy&gt;c||map[xx][yy]=='*'||cnt[xx][yy])continue; cnt[xx][yy]=cnt[tmp.x][tmp.y]+1; if(xx==fx&amp;&amp;yy==fy){ printf(&quot;%d&quot;,cnt[xx][yy]-1); exit(0);//新学的好东西，可以直接结束进程 } q.push(mp(xx,yy)); } } } int main(){ scanf(&quot;%d%d&quot;,&amp;c,&amp;r);//注意输入 for(int i=1;i&lt;=r;++i){ for(int j=1;j&lt;=c;++j){ scanf(&quot; %c&quot;,&amp;map[i][j]); if(map[i][j]=='K')sx=i,sy=j; if(map[i][j]=='H')fx=i,fy=j; } } bfs(); return 0; } 练习: P1588 [USACO07OPEN]Catch That Cow S P2199 最后的迷宫 多源 BFS:BFS:BFS: 我们知道，一般的 BFSBFSBFS 都是在同一张图里，对图里的状态做出改变。但有时候，我们需要把整张图作为一个状态，通过这个状态变成另一张图，问最小需要多少步数变成目标状态。也就是说我们要维护的信息由局部变成了整体，这就需要我们的多源 BFSBFSBFS。 我们来开启例题 173. 矩阵距离 Description:Description:Description: 给定一个 NNN 行 MMM 列的 010101 矩阵 AAA，A[i][j]A[i][j]A[i][j] 与 A[k][l]A[k][l]A[k][l] 之间的曼哈顿距离定义为： dist(A[i][j],A[k][l])=∣i−k∣+∣j−l∣dist(A[i][j],A[k][l])=|i-k|+|j-l| dist(A[i][j],A[k][l])=∣i−k∣+∣j−l∣ 输出一个 NNN 行 MMM 列的整数矩阵 BBB，其中： B[i][j]=min1≤x≤N,1≤y≤M,A[x][y]=1dist(A[i][j],A[x][y])B[i][j]=min_{1≤x≤N,1≤y≤M,A[x][y]=1}dist(A[i][j],A[x][y]) B[i][j]=min1≤x≤N,1≤y≤M,A[x][y]=1​dist(A[i][j],A[x][y]) 简单点说，就是求矩阵中所有位置到离这个位置最近的值为 111 的位置的距离。 Solution:Solution:Solution: 还是利用我们所知的 BFSBFSBFS 的性质：边权相同时，从起点搜起，第一次搜到某个点的路径就是到这个点的单源最短路径。 先来想一下朴素做法： 我们从每个 111 开始做 BFSBFSBFS ，然后每遍历到一个点就保留最小值，这个复杂度显然是会炸掉的（大概是 O(n4)O(n^4)O(n4)），我们要想想怎么去优化这个做法。 想一想图论里是怎么做的，假如我们要求一个点离它最近的起点的最短距离（注意：这跟多源 BFSBFSBFS 还是有区别的），我们可以把这个问题转化为单源最短路径：我们可以建一个超级源点，这个源点向每一个起点连一条权值为 000 的边，那么从一个点到离它最近的起点的最短路径，就可以转化为从这个点到超级源点的最短路径，所以直接从这个超级源点跑最短路就行了。 那么我们在 BFSBFSBFS 里面也可以使用这种思想，只不过我们不需要建超级源点，在这道题里面我们可以把每一个 111 的位置初始化成 000 ，再添加到队列里面，然后我们按照普通的最短路模型去跑就行了。 就行了。 为甚么这样是正确的呢？ 我们需要证明两个性质： 两段性：就是说，我们最多（因为初始状态都是一样的所以只有一段）可以把 BFSBFSBFS 的队列分成两个有相同值的段，若左边的那一段是 xxx，则右边的一定是 x+1x+1x+1。 Proof:Proof:Proof: 从初始状态出发，初始状态都是 000 ，则显然我们取出队头遍历之后插回队尾的一定是 111。再依此类推，假若我们队头取出的是 xxx ,则遍历之后插入队尾的一定是 x+1x+1x+1。故两段性成立。 单调性：也就是说队列里的值是满足单调性的，由前面的两段性很好推出。 通过这两个性质，我们可以证明出每个结点出队的时候，所存的一定是最短距离。 Proof:Proof:Proof: 首先，初始化的时候显然存的是最短距离。我们可以用反证法：假设之前出队的点最小值已经确定了，那么当前队头元素的最小值也确定了；如果没有确定，那么队列后面必然存在一个元素，它通过遍历可以得到当前队头的这个元素，但又根据单调性，后面的这个元素值一定大于等于前面元素的值，加上每条边权都是 111，所以后面这个元素走一圈回到队头这个元素的距离显然一定大于队头元素所存的距离，因此队头元素一定存的是最小值。 所以这个做法是正确的，这样我们也解释了一开始的那个性质为什么成立。 Code:Code:Code: #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; const int N=1010; typedef pair&lt;int,int&gt; p; #define mp(x,y) make_pair(x,y) #define x first #define y second int n,m; int g[N][N],dist[N][N]; int f[4][2]={{-1,0},{1,0},{0,-1},{0,1}}; bool vis[N][N]; queue&lt;p&gt; q; void bfs(){ while(!q.empty()){ p tmp=q.front();q.pop(); for(int i=0;i&lt;4;++i){ int xx=tmp.x+f[i][0],yy=tmp.y+f[i][1]; if(xx&lt;=0||xx&gt;n||yy&lt;=0||yy&gt;m||vis[xx][yy])continue; dist[xx][yy]=dist[tmp.x][tmp.y]+1; vis[xx][yy]=true; q.emplace(mp(xx,yy)); } } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ scanf(&quot;%1d&quot;,&amp;g[i][j]); if(g[i][j]){ q.emplace(mp(i,j));//又是个新东西，等价于push vis[i][j]=true; } } } bfs(); for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ printf(&quot;%d &quot;,dist[i][j]); } puts(&quot;&quot;); } return 0; } 双端队列 BFS:BFS:BFS: 有的时候，我们要维护最小值，不一定要从队尾插入，也可以从队头插入以更好地求解答案，所以我们需要拿一个双端队列来维护 BFSBFSBFS。 例题：P4667 [BalticOI 2011 Day1]Switch the Lamp On Description:Description:Description: 有一种正方形的电路元件，在它的两组相对顶点中，有一组会用导线连接起来，另一组则不会。有 N×MN\\times MN×M 个这样的元件，你想将其排列成 NNN 行，每行 MMM 个。 电源连接到板的左上角。灯连接到板的右下角。只有在电源和灯之间有一条电线连接的情况下，灯才会亮着。为了打开灯，任何数量的电路元件都可以转动 90°90\\degree90°（两个方向）。 在上面的图片中，灯是关着的。如果右边的第二列的任何一个电路元件被旋转 90°90\\degree90°，电源和灯都会连接，灯被打开。现在请你编写一个程序，求出最小需要多少旋转多少电路元件。 Solution:Solution:Solution: 这道题可以理解成从左上走到右下的最短路问题，如果可以直接走的话边权就为 000，如果要旋转后才能走的话边权就为 111。也就是说，我们要在这样一个边权只有 000 或 111 两种情况的无向图中走最短路。 先来看看无解的情况吧，我们来看下面这张图： 上面圈红色的点是无论如何都到不了的，我们可以从中找一下性质，我们可以发现，到不了的点其横纵坐标和都为奇数，到的了的点和都为偶数，所以可以靠这个性质判断是否有解。 我们前面说到的 BFSBFSBFS 的性质是在边权都一样的情况的，然而这道题边权有两种，我们该怎么处理呢？（当然这道题用 DijkstraDijkstraDijkstra 是可以过的） 这就需要我们的双端队列 BFSBFSBFS 了，在 BFSBFSBFS 的队列里面，我们要保证单调性，使得每一次从队头取出来的元素都是当前最小的，所以我们每次取出元素遍历时，遇到权值为 000 的边，就把他放到队首，反之则放到队末，这样就可以保证单调性了，也说明这个做法是正确的（可以参考上面多源 BFSBFSBFS 的单调性证明）。其余部分都与一般的 BFSBFSBFS 是一样的。 Code:Code:Code: #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int N = 501; typedef pair&lt;int,int&gt; p; #define x first #define y second int n,m,dis[N][N]; int f1[4][2]={{-1,-1},{-1,1},{1,-1},{1,1}};//点与点的坐标关系：左上、右上、左下、右下 int f2[4][2]={{-1,-1},{-1,0},{0,-1},{0,0}};//点与边的坐标关系：左上、右上、左下、右下 char g[N][N],edge[5]=&quot;\\\\//\\\\&quot;;//四个方向的边能顺着走的样子（多打一个‘\\’是转义） bool vis[N][N]; int bfs(){ deque&lt;p&gt;q; memset(vis,0,sizeof vis); memset(dis,0x3f,sizeof dis); dis[0][0]=0;//注意点从(0,0)开始 q.push_back({0,0}); while(!q.empty()){ p tmp=q.front();q.pop_front(); if(tmp.x==n&amp;&amp;tmp.y==m)return dis[n][m]; if(vis[tmp.x][tmp.y])continue; vis[tmp.x][tmp.y]=true; for(int i=0;i&lt;4;++i){ int px=tmp.x+f1[i][0],py=tmp.y+f1[i][1];//点坐标 if(px&lt;0||px&gt;n||py&lt;0||py&gt;m)continue; int ex=tmp.x+f2[i][0],ey=tmp.y+f2[i][1];//边坐标 int w=(g[ex][ey]!=edge[i]);//获得边权：需不需要旋转 int dist=dis[tmp.x][tmp.y]+w; if(dist&lt;dis[px][py]){//更新 dis[px][py]=dist; if(!w)q.push_front({px,py}); else q.push_back({px,py}); } } } return 0; } int main(){ int t; scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;++i){ for(int j=0;j&lt;m;++j){ scanf(&quot; %c&quot;,&amp;g[i][j]); } } if((n+m)&amp;1){ puts(&quot;NO SOLUTION&quot;); continue; } printf(&quot;%d\\n&quot;,bfs()); } return 0; } 最小步数模型： 顾名思义，就是用来求解通过一种或几种方式，从一个状态到目标状态的最小步数，这里来看一下例题 P2730 [USACO3.2]魔板 Magic Squares Description:Description:Description: 这是一张有 888 个大小相同的格子的魔板： 1 2 3 4 8 7 6 5 我们知道魔板的每一个方格都有一种颜色。 这 888 种颜色用前 888 个正整数来表示。 可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。 对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8)(1,2,3,4,5,6,7,8)(1,2,3,4,5,6,7,8) 来表示，这是基本状态。 这里提供三种基本操作，分别用大写字母 AAA，BBB，CCC 来表示（可以通过这些操作改变魔板的状态）： A：交换上下两行； B：将最右边的一列插入到最左边； C：魔板中央对的4个数作顺时针旋转。 下面是对基本状态进行操作的示范： A： 8 7 6 5 1 2 3 4 B： 4 1 2 3 5 8 7 6 C： 1 7 2 4 8 6 3 5 对于每种可能的状态，这三种基本操作都可以使用。 你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。 Solution:Solution:Solution: 这类的题往往有一些特点，那就是状态的存储，一般来说，我们状态可以用哈希表来存储。在这个问题里，我们用哈希表来存每个状态是否出现过，如果没出现过就记录下这个方案。除此之外我们还要记录当前状态是由哪个状态得来的，这个相比于前面的迷宫问题比较特殊，必须从起点开始推，所以最后记录一下答案然后 reversereversereverse 一下就行。 Code:Code:Code: #include&lt;unordered_map&gt;//注意考场上不能用 #include&lt;queue&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; string st,ed; unordered_map&lt;string,int&gt;dist; unordered_map&lt;string,pair&lt;char,string&gt;&gt;pre; queue&lt;string&gt;q; //对应三个操作 string A(string now){ for(int i=0;i&lt;=3;++i)swap(now[i],now[7-i]); return now; }//1 2 3 4 5 6 7 8-&gt;8 7 6 5 4 3 2 1 string B(string now){ string res=now;int k=0; res[0]=now[3];res[7]=now[4]; for(int i=0;i&lt;3;++i)res[++k]=now[i]; for(int i=5;i&lt;8;++i)res[++k]=now[i]; return res; }//1 2 3 4 5 6 7 8-&gt;4 1 2 3 6 7 8 5 string C(string now){ string res=now; res[1]=now[6];res[2]=now[1];res[5]=now[2];res[6]=now[5]; return res; }//1 2 3 4 5 6 7 8-&gt;1 7 2 4 5 3 6 8 void bfs(){ q.push(st); while(!q.empty()){ string tmp=q.front();q.pop(); //提前预处理 string state[3]; state[0]=A(tmp); state[1]=B(tmp); state[2]=C(tmp); for(int i=0;i&lt;3;++i){ if(!dist.count(state[i])){ dist[state[i]]=dist[tmp]+1; pre[state[i]]={(char)(i+'A'),tmp}; if(state[i]==ed){ return; } q.push(state[i]); } } } } int main(){ //预处理起始和终点状态 for(int i=1;i&lt;=8;i++){ int x;scanf(&quot;%d&quot;,&amp;x); ed+=(char)(x+'0'); } for(int i=1;i&lt;=8;++i)st+=(char)(i+'0'); bfs(); printf(&quot;%d\\n&quot;,dist[ed]); string res; while(ed!=st){ res+=pre[ed].first; ed=pre[ed].second; } reverse(res.begin(),res.end());//逆序 cout&lt;&lt;res; return 0; } 先咕到这里 ","link":"https://reqwq.github.io/post/tu-lun-sou-suo-suan-fa-xue-xi-bi-ji/"},{"title":"【数论】组合数学学习笔记","content":"蒟蒻的组合数学实在是太弱了，所以在初赛之前赶紧来复习一下，大部分内容由 OI−WikiOI-WikiOI−Wiki 整合而来。 普及知识点标 JJJ，提高知识点标 SSS 加法原理&amp;乘法原理（JJJ） 加法原理 假设完成一项任务有 nnn 种方案，每种方案的办法数目为 aia_iai​，则完成这项任务的总方法数为 a1+a2+⋯+ana_1+a_2+\\cdots+a_na1​+a2​+⋯+an​。 乘法原理 假设完成一项任务分 nnn 个步骤，每种步骤又有 aia_iai​ 个办法，则完成这项任务的总方法数为 a1×a2×⋯×ana_1\\times a_2\\times\\cdots\\times a_na1​×a2​×⋯×an​。 一些排列组合的符号（JJJ） 排列数 从 nnn 个元素中选择 mmm 个组成的排列个数（n,m∈N,m≤nn,m\\in\\mathbb{N},m\\leq nn,m∈N,m≤n），用符号 AnmA_n^mAnm​ 或 PnmP_n^mPnm​ 表示，即 Anm=n(n−1)(n−2)⋯(n−m+1)=n!(n−m)!A_n^m=n(n-1)(n-2)\\cdots(n-m+1)=\\dfrac{n!}{(n-m)!} Anm​=n(n−1)(n−2)⋯(n−m+1)=(n−m)!n!​ 如何理解？假设有 nnn 个人，我们要从中选择 mmm 个人来排队。对于第一个位置，我们有 nnn 个人可以选；因为选掉了一个人，第二个位置就只剩下 (n−1)(n-1)(n−1) 个人可以选。依次类推，第 mmm 个位置就有 (n−m+1)(n-m+1)(n−m+1) 个人可以选，根据乘法原理把它们相乘起来就是了。 全排列 即 nnn 个元素组成的排列个数：Ann=n!A_n^n=n!Ann​=n! 排列数的递推公式 递推边界：∀i∈N,Ai1=1\\text{递推边界：}\\forall i\\in\\mathbb{N},A_i^1=1 递推边界：∀i∈N,Ai1​=1 Anm=Anm−1×(n−m+1)A_n^m=A_n^{m-1}\\times(n-m+1) Anm​=Anm−1​×(n−m+1) 组合数 从 nnn 个元素中选择 mmm 个组成的组合个数（n,m∈N,m≤nn,m\\in\\mathbb{N},m\\leq nn,m∈N,m≤n），用符号 CnmC_n^mCnm​ 表示，为了表达方便可以简写成 (nm)\\dbinom{n}{m}(mn​)，即 Cnm=Anmm!=n!m!(n−m)!C_n^m=\\dfrac{A_n^m}{m!}=\\dfrac{n!}{m!(n-m)!} Cnm​=m!Anm​​=m!(n−m)!n!​ 如何理解？如果我们从 nnn 个人中选 mmm 个人，如果不在乎顺序，就是 CnmC_n^mCnm​，如果在乎顺序，则选出来的 mmm 个人还要再全排，得到 AnmA_n^mAnm​。则 Anm=Cnm×Amm=Cnm×m!A_n^m=C_n^m\\times A_m^m=C_n^m\\times m! Anm​=Cnm​×Amm​=Cnm​×m! 组合数的递推公式 递推边界：∀i∈N,Ci0=1\\text{递推边界：}\\forall i\\in\\mathbb{N},C_i^0=1 递推边界：∀i∈N,Ci0​=1 Cnm=Cn−1m+Cn−1m−1C_n^m=C_{n-1}^{m}+C_{n-1}^{m-1} Cnm​=Cn−1m​+Cn−1m−1​ 如何理解这个递推公式？我们只需要简单的举个例子。我们可以把 CnmC_n^mCnm​ 这个方案，分成两个集合：包含 111 与不包含 111。 如果不包含 111 这个数，则我们需要在剩下的 222 到 nnn 这 (n−1)(n-1)(n−1) 个数里面选择 mmm 个数，即 Cn−1mC_{n-1}^{m}Cn−1m​。 如果包含，则我们需要在剩下的 222 到 nnn 这 (n−1)(n-1)(n−1) 个数里面选择 (m−1)个数(m-1) 个数(m−1)个数，即 Cn−1m−1C_{n-1}^{m-1}Cn−1m−1​。根据加法原理把两个集合的方案相加即可。 组合数一些简单的东西 组合数的对称性（JJJ） (nm)=(nn−m)\\dbinom{n}{m}=\\dbinom{n}{n-m} (mn​)=(n−mn​) proof:proof:proof: 即对选出来的集合对全集取补集，数值不变。 二项式定理（SSS） (a+b)n=∑i=0n(ni)aibn−i(a+b)^n=\\sum_{i=0}^n\\dbinom{n}{i}a^{i}b^{n-i} (a+b)n=i=0∑n​(in​)aibn−i 其用组合数阐明了一个展开式的系数，可以用数学归纳法证明，可是窝太菜了不会，只好给出我的非数学归纳法的证明： 首先我们可以把左边的柿子化成 (a+b)(a+b)⋯+(a+b)⎵n个(a+b)\\begin{matrix}\\underbrace{(a+b)(a+b)\\cdots+(a+b)}\\\\n\\text{个}(a+b)\\end{matrix} (a+b)(a+b)⋯+(a+b)​n个(a+b)​ 这个柿子展开后有 2n2^n2n 项，我们要将展开后的柿子合并同类项，最终每一项都形如 k×aibn−ik\\times a^ib^{n-i}k×aibn−i。我们想知道的就是前面的 kkk，那么我们就得出一个问题，对于每一个 i (0≤i≤n)i\\ (0\\le i\\le n)i (0≤i≤n)，有多少个 aibn−ia^ib^{n-i}aibn−i，即从 nnn 个 aaa 中选 iii 个 aaa 方案个数（剩下的都是 bbb 所以不用管），即 (ni)\\dbinom{n}{i}(in​)。所以 k=(ni)k=\\dbinom{n}{i}k=(in​)，所以二项式定理成立。 杨辉三角（JJJ） 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 1 10 45 120 210 252 210 120 45 10 1 这是杨辉三角的 000 至 101010 行，我们会发现第 iii 行第 jjj 个数（jjj 从 000 开始）对应着 (a+b)i(a+b)^i(a+b)i 展开式的系数 (ij)\\dbinom{i}{j}(ji​)，第 nnn 行 mmm 列的数（设为 an,ma_{n,m}an,m​）的递推式为 an,m=an−1,m+an−1,m−1a_{n,m}=a_{n-1,m}+a_{n-1,m-1} an,m​=an−1,m​+an−1,m−1​ 由于 an,m=(nm)a_{n,m}=\\dbinom{n}{m}an,m​=(mn​)，可以推出 (nm)=(n−1n)+(n−1m−1)\\dbinom{n}{m}=\\dbinom{n-1}{n}+\\dbinom{n-1}{m-1} (mn​)=(nn−1​)+(m−1n−1​) 这同时也证明了组合数的递推式。 组合数的另一个递推式 (nm)=nm(n−1m−1)\\dbinom{n}{m}=\\dfrac{n}{m}\\dbinom{n-1}{m-1} (mn​)=mn​(m−1n−1​) proof:proof:proof: (nm)=n!m!(n−m)!=nm×(n−1)!(m−1)!(n−1−m+1)!=nm(n−1m−1)\\dbinom{n}{m}=\\dfrac{n!}{m!(n-m)!}=\\dfrac{n}{m}\\times\\dfrac{(n-1)!}{(m-1)!(n-1-m+1)!}=\\dfrac{n}{m}\\dbinom{n-1}{m-1} (mn​)=m!(n−m)!n!​=mn​×(m−1)!(n−1−m+1)!(n−1)!​=mn​(m−1n−1​) 其他一些杂七杂八的东西 (n0)+(n1)+⋯+(nn)=∑i=0n(ni)=2n(1)\\dbinom{n}{0}+\\dbinom{n}{1}+\\cdots+\\dbinom{n}{n}=\\sum_{i=0}^n\\dbinom{n}{i}=2^n\\qquad\\qquad(1) (0n​)+(1n​)+⋯+(nn​)=i=0∑n​(in​)=2n(1) (n0)−(n1)+(n2)−⋯+(−1)n(nn)=[n=0](2)\\dbinom{n}{0}-\\dbinom{n}{1}+\\dbinom{n}{2}-\\cdots+(-1)^n\\dbinom{n}{n}=[n=0]\\qquad\\quad(2) (0n​)−(1n​)+(2n​)−⋯+(−1)n(nn​)=[n=0](2) (n0)+(n2)+(n4)+⋯=(n1)+(n3)+(n5)+⋯=2n−1(3)\\dbinom{n}{0}+\\dbinom{n}{2}+\\dbinom{n}{4}+\\cdots=\\dbinom{n}{1}+\\dbinom{n}{3}+\\dbinom{n}{5}+\\cdots=2^{n-1}\\quad(3) (0n​)+(2n​)+(4n​)+⋯=(1n​)+(3n​)+(5n​)+⋯=2n−1(3) proof:proof:proof: 当 a=b=1a=b=1a=b=1 时，代入二项式定理可以证明 (1)(1)(1) 式；当 a=1,b=−1a=1,b=-1a=1,b=−1 时，代入二项式定理可证明 (2)(2)(2) 式；(1)式+(2)式2\\frac{(1)\\text{式}+(2)\\text{式}}{2}2(1)式+(2)式​ 可以证明 (3)(3)(3) 式。 一些解题技巧 例题1. 六个人站一排，求 （1）甲不在排头，乙不在排尾的方案数。 （2）在上一小问的前提下，甲乙不相邻的方案数。 可以先思考一下。 解答： （1）：对于这类题，我们可以用“正难则反”的方法。什么叫正难则反呢？就是对于从正面很难解答的题型，我们从反面来推。 如这道题，我们发现直接硬算很麻烦，我们可以换一种思路：求出六个人的全排列，再减去甲在排头的方案数和乙在排尾的方案数就行了。答案为 A66−A55−A55=6!−5!−5!=480A_6^6-A_5^5-A_5^5=6!-5!-5!=480 A66​−A55​−A55​=6!−5!−5!=480 如果您觉得这正确，那就大错特错了，因为甲在排头，并且乙在排尾被多减了一次！根据容斥原理，我们要把多减去的那部分再加回来，所以正确的答案应该是 A66−A55−A55+A44=504A_6^6-A_5^5-A_5^5+A_4^4=504 A66​−A55​−A55​+A44​=504 （2）： 这里我们用分类讨论的方法，我们分四种情况讨论： 甲在排尾，乙在排头：显然，甲乙位置确定中间四个随便排，方案数为 A44A_4^4A44​。 甲在排尾，乙不在排头：那么乙只有 333 种选择（不在排头，且不与甲相邻），剩下的四人随便排，方案数为 3×A443\\times A_4^43×A44​。 甲不在排尾，乙在排头：对称地，方案数为 3×A443\\times A_4^43×A44​。 甲不在排尾，乙不在排头：我们还可以再分讨： 甲在 222 号位：那么乙只有两种选法，方案数为 2×A442\\times A_4^42×A44​。 甲在 333 号位：那么乙只有一种选法，方案数为 A44A_4^4A44​。 甲在 444、555 号位的情况分别于在 333、222 号位的情况相同。 综上，总方案数为 A44+3×A44×2+2×A44×2+A44×2=312A_4^4+3\\times A_4^4\\times 2+2\\times A_4^4\\times2+A_4^4\\times2=312 A44​+3×A44​×2+2×A44​×2+A44​×2=312 例题2. 八个人站一排，求 （1）甲乙必须相邻的排列数。 （2）甲乙必须不相邻的排列数。 解答： （1）：对于这类题，我们可以采用捆绑法，即将甲乙看作一个人，那么就是七个人求全排列，同时甲乙之间是有序的，其内部还需要全排列，所以答案为 A77∗A22=10080A_7^7*A_2^2=10080 A77​∗A22​=10080 （2）：这个就很水了，“正难则反”，用八个人的全排列减去甲乙相邻的方案数就行，答案不用我说了。 例题3. 某人射击 888 枪，命中 444 枪，恰好有 333 枪连续命中，有多少种不同情况？ 解答： 这题应使用捆绑法解答，把连续的 333 枪看作一个，但注意是恰好有 333 枪连续命中，也就是说另外一枪和这三枪不能相邻，如果容斥或者分讨将会非常麻烦，有什么更简单的方法呢？ 这里就要使用我们的插空法，有时也叫隔板法。 什么意思呢？我们将没命中的四枪提取出来， _·_·_·_·_ 我们发现，相邻两枪中间都有空位，总共有 4+1=54+1=54+1=5 个空位，我们只要将捆绑的 333 枪和另外一枪插入到这些空位中，不就满足它们不相邻了嘛？由于这几枪都是无序的，所以答案就是 C52C_5^2C52​。 例题4. 求不定方程 ∑i=1nxi=m\\sum\\limits_{i=1}^nx_i=mi=1∑n​xi​=m 的正整数解个数。 解答： 这题需要用到隔板法，我们把 mmm 想象成 mmm 个相同的小球，我们要把这些小球分成 nnn 份有多少个方案呢？我们可以在这些小球之间的空位中放入 (n−1)(n-1)(n−1) 个隔板（一个空位最多只能放一个隔板），这样就能把这些小球分成 nnn 份了。由于两端不能放隔板，所以有 (m−1)(m-1)(m−1) 个空位，答案为 Cm−1n−1C_{m-1}^{n-1}Cm−1n−1​。 例题5. 求不定方程 ∑i=1nxi=m\\sum\\limits_{i=1}^nx_i=mi=1∑n​xi​=m 的非负整数解个数。 这题看似和上一题一样，但 xix_ixi​ 变成了非负整数，也就是说 xix_ixi​ 可以为 000，那这样隔板可以放在一起，这怎么算呢？ 令 yi=xi+1y_i=x_i+1yi​=xi​+1，则有 ∑i=1nyi=m+n\\sum\\limits_{i=1}^{n}y_i=m+ni=1∑n​yi​=m+n。我们发现，这里的 yiy_iyi​ 都是正整数，且每一个 yiy_iyi​ 的解都对应一个 xix_ixi​，那么我们就很好地转化成了上题，答案即为 Cm+n−1n−1C_{m+n-1}^{n-1}Cm+n−1n−1​。 组合数学进阶（SSS） 卡特兰数 例题：P1044 [NOIP2003 普及组] 栈 定义 HnH_nHn​ 为卡特兰数的第 nnn 项。 亿些递推公式 递推边界： H0=1.H_0=1.H0​=1. Hn=(2nn)n+1H_n=\\dfrac{\\binom{2n}{n}}{n+1} Hn​=n+1(n2n​)​ Hn=Hn−1(4n−2)n+1线性递推，超好用！！1H_n=\\dfrac{H_{n-1}(4n-2)}{n+1}\\quad\\text{线性递推，超好用！！1} Hn​=n+1Hn−1​(4n−2)​线性递推，超好用！！1 Hn=(2nn)−(2nn−1)H_n=\\dbinom{2n}{n}-\\dbinom{2n}{n-1} Hn​=(n2n​)−(n−12n​) Hn={∑i=1nHi−1Hn−in≥21n=1,0H_n=\\begin{cases}\\sum_{i=1}^nH_{i-1}H_{n-i} &amp; n\\ge2 \\\\1 &amp; n=1,0\\end{cases} Hn​={∑i=1n​Hi−1​Hn−i​1​n≥2n=1,0​ 要用到卡特兰数的问题 有 2n2n2n 个人排成一行进入剧场。入场费 555 元。其中只有 nnn 个人有一张 555 元钞票，另外 nnn 人只有 101010 元钞票，剧院无其它钞票，问有多少中方法使得只要有 101010 元的人买票，售票处就有 555 元的钞票找零？ 一位大城市的律师在她住所以北 nnn 个街区和以东 nnn 个街区处工作。每天她走 2n2n2n 个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 在圆上选择 2n2n2n 个点，将这些点成对连接起来使得所得到的 nnn 条线段不相交的方法数？ 对角线不相交的情况下，将一个凸多边形区域分成三角形区域的方法数？ 一个栈（无穷大）的进栈序列为 1,2,3,⋯ ,n1,2,3,\\cdots,n1,2,3,⋯,n，有多少个不同的出栈序列？ nnn 个结点可构造多少个不同的二叉树？ 将 nnn 个 +1+1+1 和 nnn 个 −1-1−1 构造成 2n2n2n 项的数列 a1,a2,⋯ ,a2na_1,a_2,\\cdots,a_{2n}a1​,a2​,⋯,a2n​，满足 ∀k∈[1,2n],∑i=1kai≥0\\forall k\\in[1,2n],\\sum_{i=1}^k a_i \\ge0∀k∈[1,2n],∑i=1k​ai​≥0 的方案数为？ 第二类斯特林数 不说第一类是因为第一类不常见。 例题：P3904 三只小猪 定义：S(n,m)S(n,m)S(n,m) （或简写成 {nm}\\begin{Bmatrix}n\\\\m\\end{Bmatrix}{nm​}）表示将 nnn 个两两不同的元素，划分为 mmm 个互不区分的非空子集的方案数。 递推公式 递推边界 S(n,0)=[n=0].S(n,0)=[n=0].S(n,0)=[n=0]. S(n,m)=S(n−1,m−1)+m×S(n−1,m)S(n,m)=S(n-1,m-1)+m\\times S(n-1,m) S(n,m)=S(n−1,m−1)+m×S(n−1,m) 递推式的解释可见我的题解 错排列 例题：P1595 信封问题 定义: f(n)f(n)f(n) 表示将 nnn 个元素错排（就是第 iii 个元素不能放到第 iii 个位置）的方案数。 递推公式： 递推边界：f(0)=0,f(1)=1.f(0)=0,f(1)=1.f(0)=0,f(1)=1. f(n)=(n−1)(f(n−1)+f(n−2))f(n)=(n-1)(f(n-1)+f(n-2)) f(n)=(n−1)(f(n−1)+f(n−2)) 如何理解？对于第 nnn 个元素，它肯定不能放在第 nnn 个位置，只能放在前面的 (n−1)(n-1)(n−1) 个位置上，设 k=1,2,⋯ ,n−1k=1,2,\\cdots,n-1k=1,2,⋯,n−1，我们可以把第 nnn 个元素放在第 kkk 个位置上，而原来第 kkk 个位置上的元素有两种选择： 交换到第 nnn 个位置上，方案数就是对剩下的 (n−2)(n-2)(n−2) 个元素错排，即 f(n−2)f(n-2)f(n−2)。 不到第 nnn 个位置上，方案数就是除去第 nnn 个位置外的 (n−1)(n-1)(n−1) 个元素错排，即 f(n−1)f(n-1)f(n−1)。 对于 kkk 有 (n−1)(n-1)(n−1) 种取值，总方案数即为 f(n)=(n−1)(f(n−1)+f(n−2))f(n)=(n-1)(f(n-1)+f(n-2))f(n)=(n−1)(f(n−1)+f(n−2))。 圆排列 定义：nnn 个人全部来围成一圈，所有的排列数记为 QnnQ_n^nQnn​。 由于从不同的位置断开会变成不同的队列，有 Qnn×n=Ann⇒Qnn=Annn=(n−1)!Q_n^n\\times n=A_n^n\\Rightarrow Q_n^n=\\dfrac{A_n^n}{n}=(n-1)! Qnn​×n=Ann​⇒Qnn​=nAnn​​=(n−1)! 由此可知，从 nnn 个人中选 mmm 个人来围成一圈的排列数为 Qnm=Anmm=n!m×(n−m)!Q_n^m=\\dfrac{A_n^m}{m}=\\dfrac{n!}{m\\times(n-m)!} Qnm​=mAnm​​=m×(n−m)!n!​ 容斥原理 直接看 oi−wikioi-wikioi−wiki 吧太多了不想写（ 鸽巢原理 也叫抽屉原理，它常被用于证明存在性和求最坏情况下的解。——OI−WikiOI-WikiOI−Wiki 简单情况 将 n+1n+1n+1 个元素分成 nnn 组，那么至少一组有两个（或以上）个元素。 证明显然。 推广到一般情况 将 nnn 个元素分成 kkk 组，则至少一组有大于等于 ⌈nk⌉\\Big\\lceil\\dfrac{n}{k}\\Big\\rceil⌈kn​⌉ 个元素。 反证法证明，假设每组有小于 ⌈nk⌉\\Big\\lceil\\dfrac{n}{k}\\Big\\rceil⌈kn​⌉ 个元素，则每组最多有 (⌈nk⌉−1)(\\Big\\lceil\\dfrac{n}{k}\\Big\\rceil-1)(⌈kn​⌉−1) 个元素。 ∵(⌈nk⌉−1)×k=k⌈nk⌉−k&lt;k(nk+1)−k=n\\because(\\Big\\lceil\\dfrac{n}{k}\\Big\\rceil-1)\\times k=k\\Big\\lceil\\dfrac{n}{k}\\Big\\rceil-k&lt;k(\\dfrac{n}{k}+1)-k=n∵(⌈kn​⌉−1)×k=k⌈kn​⌉−k&lt;k(kn​+1)−k=n. ∴\\therefore∴ 矛盾. 总结，将 nnn 个元素划分成 A1,A2,⋯ ,AkA_1,A_2,\\cdots,A_kA1​,A2​,⋯,Ak​ ,kkk 个集合，则至少有一个集合 AiA_iAi​ 满足 Ai≥⌈nk⌉A_i\\ge\\Big\\lceil\\dfrac{n}{k}\\Big\\rceilAi​≥⌈kn​⌉。 Thank you for reading!Thank\\ you\\ for\\ reading!Thank you for reading! ","link":"https://reqwq.github.io/post/shu-lun-zu-he-shu-xue-xue-xi-bi-ji/"},{"title":"【DS】 线段树分裂&合并学习笔记","content":"大家好哇，我又来学数据结构了。 参考资料： 不分解的氢氧化银 模板题解 前置芝士： 线段树（废话） 动态开点 亿点树上问题基础 线段树合并 顾名思义，我们要把两颗线段树合并在一起，如图 （假设我们要维护的是权值和的信息，维护其他信息只需要稍作更改） 实现起来很简单，我们只需要把对应位置相加起来就行了。 //稍微改了下马蜂（ void merge(int &amp;x,int y) { if(!x||!y) x|=y; else { tre[x].val+=tre[y].val; merge(ls(x),ls(y)); merge(rs(x),rs(y)); } } 为了节省空间不开新点，直接将 y 树合并到 x 树上，但这样做的前提是在之后的操作中，y 树不会再出现。因为我们直接合并的话，x 和 y 树是共用一个结点的，如果对其中一棵树有更改，会对另一棵树有影响。因此，如果 y 树合并后还会再出现，建议新开点存合并后的树。 有人问，这两次递归都调用了，时间复杂度不是 O(n)O(n)O(n) 的嘛？ 不是的，是 O(log⁡n)O(\\log n)O(logn)，证法有点玄学，窝不会（ 线段树分裂 顾名思义，就是合并反过来操作。线段树的分裂，有按权值分裂和按区间分裂（怎么一股 fhq 的味道），这里依次讲解。 按权值分裂（按 kkk 小分裂） void split(int x,int &amp;y,int k) {//x为原（子）树，分裂后为前k小的树，y为剩下的树 y=++cnt;int val=tre[ls(x)].val; if(k&gt;v) split(rs(x),rs(y),k-v); else swap(rs(x),rs(y)); if(k&lt;v) split(ls(x),ls(y),k); tre[y].val=tre[x].val-k; tre[x].val=k; } 这里我们分情况讨论：（vvv 为左子树的权值/大小） 当 v&lt;kv&lt;kv&lt;k 时，左子树给 xxx 不用处理，直接分裂右子树。 当 v≥kv\\ge kv≥k 时，右边归 yyy ，swap 一下就行。 当 v&gt;kv&gt;kv&gt;k 时，还需要递归左边。 最后将权值赋值一下就行。 按区间分裂 很简单，像普通线段树一样，把区间剖出来就行了。 inline void pushup(int p) {tre[p].val=tre[ls(p)].val+tre[rs(p)].val;} int split(int &amp;p,int l,int r,int L,int R) {//l,r为原（子）树区间，L,R为剖出来的区间 int now=++cnt; if(L&lt;=l&amp;&amp;r&lt;=R) { tre[now]=tre[p]; p=0;return now; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) ls(now)=split(ls(p),l,mid,L,R); if(R&gt;mid) rs(now)=split(rs(p),mid+1,r,L,R); pushup(p);pushup(now); return now; } 如果原树区间被覆盖，则直接搞出来就行，把原树置为 000。 否则按普通线段树一样递归，记得更新信息。 例题 先丢上来待会写做法。 P5494 【模板】线段树分裂 P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并 P3224 [HNOI2012]永无乡 P3201 [HNOI2009] 梦幻布丁 CF600E Lomsat gelral ","link":"https://reqwq.github.io/post/ds-xian-duan-shu-fen-lie-andhe-bing-xue-xi-bi-ji/"},{"title":"【洛谷日报 #373】你所不了解的数据结构——van Emde Boas 树","content":"前言 van Emde Boas 树（以下简称 vEB 树），是由荷兰计算机科学家 Peter van Emde Boas\\mathtt{Peter\\ van\\ Emde\\ Boas}Peter van Emde Boas 于 1975 年发明的一种树数据结构。 当我翻开 《算法导论》 的目录的时候，一下子就被这个奇特的名字吸引住了。在学习过程中，我发现这个数据结构构思极其巧妙。因此，我将按照原文的思路，采用更通俗易懂的表述介绍这个数据结构，这篇文章也是我的学习笔记。此外，网上有关 vEB 树的实现均为指针实现，我这里将会给出无指针的实现。 最后，这篇文章如果有什么疏漏或错误之处，还请读者指出。这篇文章仅作抛砖引玉啦~ 0.0.0. 前置芝士 一定的树数据结构知识。 master 定理（分析时间复杂度的时候用）。 1.1.1. 引入 我们知道，像红黑树，二叉堆等支持优先队列操作的数据结构，它们的某些重要操作的时间复杂度的最坏（或摊还）情况的时间复杂度需 O(log⁡n)O(\\log{n})O(logn)。 在这篇文章里，我们会看到 vEB 树也支持优先队列和一些其他操作，分别是：查询元素是否存在、插入和删除元素、查询前驱和后继、查询集合里的最大值和最小值，且每个操作的时间复杂度都只需惊人的 O(log⁡log⁡n)O(\\log{\\log{n}})O(loglogn)！！！但这个数据结构也有个限制，那就是所有关键字必须为 [0,n−1][0,n-1][0,n−1] 的整数且无重复。 为避免歧义，以后我们用 nnn 表示元素个数，uuu 表示存储关键字值的全域大小（即关键字的值域为 {0,1,2,...,u−1}\\{0,1,2,...,u-1\\}{0,1,2,...,u−1}）。其中，如无特殊要求，始终假定 u={2k:k∈N+}u=\\{2^k:k\\in\\mathbb{N}_+\\}u={2k:k∈N+​}。那么 vEB 树的每一个操作的时间复杂度都为 O(log⁡log⁡u)O(\\log{\\log{u}})O(loglogu)。 2.2.2. 简单的思路 由于我们只存储关键字的值域，可以开一个桶。若元素 iii 存在，则 A[i]=1A[i]=1A[i]=1，反之 A[i]=0A[i]=0A[i]=0。这样，查询元素是否存在、插入和删除元素的操作只需要 O(1)O(1)O(1)，但查询前驱和后继、查询集合内最大值和最小值的操作最坏需要 O(u)O(u)O(u)，因为我们需要扫描所查询元素前（后）面的所有元素，直到找到第一个存在的元素为止。 2.12.12.1 叠加结构 前面讲到，如果单开一个桶，查询前驱和后继扫描的时间将会非常久。那么，如何缩短扫描的时间呢？ 我们考虑在桶上叠加一棵二叉树，如图： 其中每一个非叶结点都代表一段值域的元素，其值为两个儿子的逻辑或，表示其代表的值域是否存在元素。我们来看看如何实现操作： 查询最大值：从根节点出发，一直走最右边的非零结点。 查询最小值：从根节点出发，一直走最左边的非零结点。 查询某个元素的前驱：从该元素出发，一直向上走，直到从右边进入某个结点，且该结点的左儿子非零，查询以该左儿子为根的最大值。（图中即为查询 141414 的前驱的过程） 查询某个元素的后继：从该元素出发，一直向上走，直到从左边进入某个结点，且该结点的右儿子非零，查询以该右儿子为根的最小值。 插入某个元素：从根节点（或该元素）出发，把从根节点到该元素的路径上的每个结点都赋值为 111。 删除某个元素：将该元素的值置为 000，然后从该元素开始，重新计算每个结点的或值（因为它的兄弟结点有可能非零，所以删掉这个元素后，其父节点不一定为 000）。 我们会发现，除了查询一个元素是否存在（直接查桶 O(1)O(1)O(1)）外，其他操作都是 O(log⁡u)O(\\log{u})O(logu)（因为只需要遍历二叉树上的一个路径），这很好地降下了复杂度。 旁白：？？？O(log⁡u)O(\\log u)O(logu)?我要的 O(log⁡log⁡u)O(\\log{\\log{u}})O(loglogu) 呢！（恼 别着急，慢慢来嘛～ 2.22.22.2 簇 有的时候，我们不一定要二叉树，我们可以像 B 树一样，使用多叉的结构。这样，整棵树的高度就减小了许多。 我们令值域 u={22k:k∈Z}u=\\{2^{2k}:k\\in \\mathbb{Z}\\}u={22k:k∈Z}，那么 u\\sqrt{u}u​ 是个整数。我们叠加一颗 u\\sqrt{u}u​ 叉树，来代替二叉树，如图 同样地，每一个非叶结点都代表一段值域的元素，其值为所有儿子的逻辑或。我们可以把这些非叶节点定义成一个数组 summarysummarysummary，其中 summary[i]summary[i]summary[i] 为 111 则代表着其子节点有 111，我们称 summary[i]summary[i]summary[i] 为第 iii 个簇。如图 我们来考虑一下如何实现一些操作： 查询最大值：在 summarysummarysummary 中查找最右边为 111 的簇，再查询该簇内最右边为 111 的元素。 查询最小值：在 summarysummarysummary 中查找最左边为 111 的簇，再查询该簇内最左边为 111 的元素。 查询某个元素的前驱：在该元素所在簇中向左找，如果有 111 则为结果，否则在 summarysummarysummary 中从该簇向左找，如果有为 111 的簇则返回这个簇的最大值。 查询某个元素的后继：在该元素所在簇中向右找，如果有 111 则为结果，否则在 summarysummarysummary 中从该簇向右找，如果有为 111 的簇则返回这个簇的最小值。 插入一个元素：置该元素和该元素所在簇为 111。 删除一个元素：置该元素为 000，重新计算该元素所在簇的逻辑或。 我们可以发现，除了插入和查询某个元素是否存在（都是 O(1)O(1)O(1)）外，其他操作的时间复杂度都为 O(u)O(\\sqrt{u})O(u​)。 旁白：？？？O(u)O(\\sqrt{u})O(u​)？好像更慢了啊喂！ 虽然慢，但这个思想为后续 vEB 树的讲解奠定了重要的基础。 3.3.3. 原型 vEB 树 本节中假设 u={22k:k∈Z}u=\\{2^{2^k}:k\\in\\mathbb{Z}\\}u={22k:k∈Z}，则有 u12,u14u^{\\frac{1}{2}},u^{\\frac{1}{4}}u21​,u41​ 等都为整数。 另外，从这节开始，有操作的部分我将会附上代码。 3.13.13.1 定义 high(x)=⌊x/u⌋high(x)=\\lfloor{x/\\sqrt{u}}\\rfloorhigh(x)=⌊x/u​⌋ low(x)=x mod ulow(x)=x\\bmod \\sqrt{u}low(x)=xmodu​ index(x,y)=xu+yindex(x,y)=x\\sqrt{u}+yindex(x,y)=xu​+y 这里一一来解释一下：为什么是 u\\sqrt{u}u​ 呢？因为值域为 uuu，每个簇的大小就为 u\\sqrt{u}u​。 high(x)high(x)high(x) 表示的是值 xxx 所在簇的编号；low(x)low(x)low(x) 表示的是值 xxx 在所在簇里面的编号；index(x,y)index(x,y)index(x,y) 则表示第 xxx 个簇的第 yyy 个元素是什么。（注意：编号也是从 000 开始的，这里所说的第 xxx 个簇指的是下面要讲的结构内的簇编号）那么我们就有 x=index(high(x),low(x))x=index(high(x),low(x))x=index(high(x),low(x))。 3.23.23.2 结构 我们考虑一种递归结构，像上面的大小为 u\\sqrt{u}u​ 的 summarysummarysummary 数组一样，其每一个元素都指向一个大小为 u\\sqrt{u}u​ 的结构。也就是说，一个大小为 u12u^{\\frac{1}{2}}u21​ 的结构，包含着 u12u^{\\frac{1}{2}}u21​ 个大小为 u14u^{\\frac{1}{4}}u41​ 的结构，其又包含着 u14u^{\\frac{1}{4}}u41​ 个大小为 u18u^{\\frac{1}{8}}u81​ 的结构，直到大小为 222 ，我们称它为基本结构。 像这样的的结构 我们定义它为原型 vEB 结构（proto_vEB）。（至于为什么是原型是因为它与真正的 vEB 结构还有区别） 下图就是一个原型 vEB 结构： 其中 uuu 代表该结构的值域大小，我们称一个值域为 [0,u−1][0,u-1][0,u−1] 的原型 vEB 结构为 proto_vEB(u)proto\\_vEB(u)proto_vEB(u)。当 u=2u=2u=2 时，这个结构是个基本结构，只包含 A[0,1]A[0,1]A[0,1]，也就是只存储两个元素的信息。当 u=2u\\not=2u​=2 时，它包含着以下特征： 包含 u\\sqrt uu​ 个簇的 clusterclustercluster 数组，每一项分别指向一个 proto_vEB(u)proto\\_vEB(\\sqrt u)proto_vEB(u​) 结构，分成更小的结构（也就是更小的簇）。 一个 summarysummarysummary 指针，它指向一个 proto_vEB(u)proto\\_vEB(\\sqrt u)proto_vEB(u​) 结构，这个结构存储了 u\\sqrt uu​ 个簇的所有信息，也就是它们的逻辑或。 结构体以及定义的实现： struct proto_vEB{ int u; bool A[2];//基本结构 int summary; vector&lt;int&gt;cluster; //用int是因为我之后建树将使用无指针 //vector是因为怕炸空间（ }tre[MAXN]; inline int high(int p,int x){ int u=(int)sqrt(tre[p].u); return x/u; } inline int low(int p,int x){ int u=(int)sqrt(tre[p].u); return x%u; } inline int index(int p,int x,int y){ int u=(int)sqrt(tre[p].u); return x*u+y; } 我们把这些结构组合起来，就形成了一个原型 vEB 树： 是不是很眼花缭乱？为了方便说明，我给每一个结构都编了序号（注意编号和序号的区分）。 这个 proto_vEB(16)proto\\_vEB(16)proto_vEB(16) 结构存储的元素集合有 {2,3,4,5,7,14,15}\\{2,3,4,5,7,14,15\\}{2,3,4,5,7,14,15}，存储它们的基本结构的序号为 12,14,15,2112,14,15,2112,14,15,21。我们可以发现，序号为 101010 的 summarysummarysummary 结构存储了序号为 11,1211,1211,12 的基本结构的信息，其中 A[1]=1A[1]=1A[1]=1 表示序号为 121212 的基础结构中有元素存在；序号为 999 的基本结构存储了序号为 5,65,65,6 的簇结构的信息(因为序号为 999 的结构是属于一个 summarysummarysummary 里的)，其中 A[0]=0A[0]=0A[0]=0 表示序号为 555 的簇结构内没有任何元素存在；同理，序号为 777 的 summarysummarysummary 结构又存储了序为 8,98,98,9 的基本结构的信息。 这里我还要补充一下上面 index(x,y)index(x,y)index(x,y) 的定义，对于一个元素 aaa，它在包含它的不同结构里的编号不一定相同，如：元素 777 在序号为 151515 的 proto_vEB(2)proto\\_vEB(2)proto_vEB(2) 结构中的编号为 111，但它在序号为 444 的 proto_vEB(4)proto\\_vEB(4)proto_vEB(4) 结构中的编号为 333。indexindexindex 不仅仅是指一个元素的编号，也可以指一个结构在 summarysummarysummary 的编号，如：序号为 555 的 proto_vEB(4)proto\\_vEB(4)proto_vEB(4) 结构在序号为 999 的 proto_vEB(2)proto\\_vEB(2)proto_vEB(2) 结构（它属于 summarysummarysummary）中的编号为 000，在序号为 777 的 proto_vEB(2)proto\\_vEB(2)proto_vEB(2) 结构中的编号为 222。 讲到这里可能会有点乱，建议反复看几次加强理解。 3.33.33.3 proto_vEB 操作实现 在讲操作之前，我要给出两个递归式，并根据《算法导论》给出解法，这两个递归式是后续操作计算时间复杂度时的两种情况： 递归式一： T(u)=T(u)+O(1)T(u)=T(\\sqrt u)+O(1) T(u)=T(u​)+O(1) 考虑变量替换法，令 m=log⁡um=\\log um=logu，则 u=2mu=2^mu=2m，有 T(2m)=T(2m2)+O(1)T(2^m)=T(2^{\\frac{m}{2}})+O(1) T(2m)=T(22m​)+O(1) 重命名 S(m)=T(2m)S(m)=T(2^m)S(m)=T(2m)，则新的递归式为 S(m)=S(m2)+O(1)S(m)=S(\\frac{m}{2})+O(1) S(m)=S(2m​)+O(1) 根据 master 定理解得 S(m)=O(log⁡m)S(m)=O(\\log m)S(m)=O(logm)，则 T(u)=T(2m)=S(m)=O(log⁡m)=O(log⁡log⁡u)T(u)=T(2^m)=S(m)=O(\\log m)=O(\\log\\log u) T(u)=T(2m)=S(m)=O(logm)=O(loglogu) 递归式二： T(u)=2T(u)+O(1)T(u)=2T(\\sqrt u)+O(1) T(u)=2T(u​)+O(1) 同样考虑变量替换法，令 m=log⁡um=\\log um=logu，则有 T(2m)=2T(2m2)+O(1)T(2^m)=2T(2^{\\frac{m}{2}})+O(1) T(2m)=2T(22m​)+O(1) 重命名 S(m)=T(2m)S(m)=T(2^m)S(m)=T(2m)，得 S(m)=2S(m2)+O(1)S(m)=2S(\\frac{m}{2})+O(1) S(m)=2S(2m​)+O(1) 根据 master 定理解得 S(m)=O(m)S(m)=O(m)S(m)=O(m)，则 T(u)=T(2m)=S(m)=O(m)=O(log⁡u)T(u)=T(2^m)=S(m)=O(m)=O(\\log u) T(u)=T(2m)=S(m)=O(m)=O(logu) 好啦，我们可以开始操作讲解啦！ 3.3.13.3.13.3.1 判断某个值是否在集合中 bool PROTO_vEB_MEMBER(int p,int x){ if(tre[p].u==2)return tre[p].A[x]; return PROTO_vEB_MEMBER(tre[p].cluster[high(p,x)],low(p,x)) } 这个很简单，如果是基本结构直接返回 AAA 数组内对应的值，否则递归查询更小的结构。由于只产生了一次递归调用，这个过程我们可以写成递归式一，时间复杂度为 O(log⁡log⁡u)O(\\log\\log u)O(loglogu)。 3.3.23.3.23.3.2 插入某个元素 void PROTO_vEB_INSERT(int p,int x){ if(tre[p].u==2)tre[p].A[x]=1; else { PROTO_vEB_INSERT(tre[p].cluster[high(p,x)],low(p,x)); PROTO_vEB_INSERT(tre[p].summary,high(p,x)); } } 这个也很简单，如果是基本结构直接置 AAA 数组对应的值为 111，否则递归插入。注意，我们不仅要把该值插入到簇里面，还要把相应的簇插入到 summarysummarysummary 里面以表示簇内有元素。此过程调用了两次递归，可以写成递归式二，时间复杂度 O(log⁡u)O(\\log u)O(logu)。 3.3.33.3.33.3.3 删除某个元素 这个相比于插入要复杂的多，我们需要判断簇中还有没有元素，可以添加属性 numnumnum 表示该簇内拥有的元素个数（这个操作《算法导论》里居然没给伪代码，可恶不能当懒人了）。相应地，我们的插入也要修改一下。 int PROTO_vEB_INSERT(int p,int x){//不保证x一定在集合内 if(tre[p].u==2){ if(!tre[p].A[x]){ ++tre[p].num; tre[p].A[x]=true; return 1; } return 0; } int tmp1=PROTO_vEB_INSERT(tre[p].cluster[high(p,x)],low(p,x)),tmp2=PROTO_vEB_INSERT(tre[p].summary,high(p,x)); tre[tre[p].cluster[high(p,x)]].num+=tmp1; tre[tre[p].summary].num+=tmp2; return tmp1+tmp2; } int PROTO_vEB_DELETE(int p,int x){//保证x一定在集合内 if(tre[p].u==2){ --tre[p].num;tre[p].A[x]=0; return 1; } int tmp1=PROTO_vEB_DELETE(tre[p].cluster[high(p,x)],low(x)),tmp2=0; tre[p].num-=tmp1; if(!tre[p].num){ tmp2=PROTO_vEB_DELETE(tre[p].summary,high(p,x)); tre[tre[p].summary].num-=tmp2; } return tmp1+tmp2; } 我们发现，两个函数的返回值都是int，它们分别表示什么意思呢？ 插入中的返回值表示的是新插入的元素的个数，同样，删除中的返回值表示的就是删除的元素的个数。 插入的部分很容易懂我就不讲了，看看删除。如果是基本结构，删除了数之后直接返回 111，否则，先从簇里删除这个数，如果删掉该数后簇为空，我们再从 summarysummarysummary 里面删掉这个簇。最后返回删掉的元素的个数。 考虑最坏情况，删除的过程要调用两次函数，可以用递归式二表示，时间复杂度 O(log⁡u)O(\\log u)O(logu)。 3.3.43.3.43.3.4 查询最小值 这里的查询最小值表示的是查询某个结构中的最小值。 int PROTO_vEB_MINIMUM(int p){ if(tre[p].u==2){ if(tre[p].A[0])return 0; if(tre[p].A[1])return 1; return NIL; } int min_cluster=PROTO_vEB_MINIMUM(tre[p].summary); if(min_cluster==NIL)return NIL; int offset=PROTO_vEB_MINIMUM(tre[p].cluster[min_cluster]); return index(min_cluster,offset); } 如果是基本结构就返回里面最小的，如果这个基础结构不包含任何元素则返回 NILNILNIL。否则，先从 summarysummarysummary 查询最小的簇，再从这个簇里面查询。如果没有最小的簇，也就是 summarysummarysummary 中不包含任何元素，则返回 NILNILNIL，否则返回最小值的编号。 这个操作需要调用两次递归，为递归式二，时间复杂度 O(log⁡u)O(\\log u)O(logu)。 由于查询最大值操作是对称的，这里就不赘述。 3.3.53.3.53.3.5 查询后继 int PROTO_vEB_SUCCESSOR(int p,int x){ if(tre[p].u==2){ if(x==0&amp;&amp;tre[p].A[1])return 1; return NIL; } int offset=PROTO_vEB_SUCCESSOR(tre[p].cluster[high(p,x)],low(p,x)); if(offset!=NIL)return index(p,high(p,x),offset); int succ_cluster=PROTO_vEB_SUCCESSOR(tre[p].summary,high(p,x)); if(succ_cluster==NIL)return NIL; offset=PROTO_vEB_MINIMUM(tre[p].cluster[succ_cluster])return index(p,succ_cluster,offset); } 如果是基本结构，判断查询的值是不是前一个元素且后一个元素存在，否则返回 NILNILNIL。不是基本结构的话，首先先看查询元素所在的簇中存不存在后继，不存在的话就在 summarysummarysummary 里面查询这个簇的后继簇，最后返回簇中最小值。 这里的时间复杂度比较特殊，我们需要调用两次查询后继的函数和一次最小值函数，可以列出这样的递归式： T(u)=2T(u)+O(log⁡u)=2T(u)+O(log⁡u)T(u)=2T(\\sqrt u)+O(\\log\\sqrt u)=2T(\\sqrt u)+O(\\log u) T(u)=2T(u​)+O(logu​)=2T(u​)+O(logu) 还是变量替换法，令 m=log⁡um=\\log um=logu，则有 T(2m)=2T(2m2)+O(m)T(2^m)=2T(2^{\\frac{m}{2}})+O(m) T(2m)=2T(22m​)+O(m) 重命名 S(m)=T(2m)S(m)=T(2^m)S(m)=T(2m)，得 S(m)=2S(m2)+O(m)S(m)=2S(\\frac{m}{2})+O(m) S(m)=2S(2m​)+O(m) 根据 master 定理解得 S(m)=O(mlog⁡m)S(m)=O(m\\log m)S(m)=O(mlogm)，则 T(u)=T(2m)=S(m)=O(mlog⁡m)=O(log⁡ulog⁡log⁡u)T(u)=T(2^m)=S(m)=O(m\\log m)=O(\\log u\\log\\log u) T(u)=T(2m)=S(m)=O(mlogm)=O(loguloglogu) 查询前驱操作也是对称的，这里也不赘述。 至此，原型 vEB 树的部分已经讲完。虽然原型 vEB 树的效率已经很好，但是还没全部达到预期的 O(log⁡log⁡u)O(\\log\\log u)O(loglogu)。接下来，我们将会看到真正的 vEB 树是如何将这些操作优化至 O(log⁡log⁡u)O(\\log\\log u)O(loglogu)的。 4.4.4. 真正的 vEB 还记得第 333 节中的假设吗？u=22ku=2^{2^k}u=22k，这个假设局限性太大了。在真正的 vEB 里，我们允许 u={2k:k∈N+}u=\\{2^k:k\\in\\mathbb{N}_+\\}u={2k:k∈N+​}，但这样，u\\sqrt uu​ 就不一定是整数了。 这里我们记 2⌈log⁡u2⌉=↑ ⁣ ⁣ ⁣ ⁣ ⁣u2^{\\lceil\\frac{\\log u}{2}\\rceil}=^\\uparrow\\!\\!\\!\\!\\!\\sqrt u2⌈2logu​⌉=↑u​，2⌊log⁡u2⌋=↓ ⁣ ⁣ ⁣ ⁣ ⁣u2^{\\lfloor\\frac{\\log u}{2}\\rfloor}=^\\downarrow\\!\\!\\!\\!\\!\\sqrt u2⌊2logu​⌋=↓u​（这 LaTex 有够难打的），即 uuu 的上、下平方数（有 u=↑ ⁣ ⁣ ⁣ ⁣ ⁣u×↓ ⁣ ⁣ ⁣ ⁣ ⁣uu=^\\uparrow\\!\\!\\!\\!\\!\\sqrt u\\times^\\downarrow\\!\\!\\!\\!\\!\\sqrt uu=↑u​×↓u​）。那么，我们之前定义的函数也要有所修改： high(x)=⌊x/ ↓ ⁣ ⁣ ⁣ ⁣u⌋high(x)=\\lfloor{x/\\ ^\\downarrow\\!\\!\\!\\!\\sqrt{u}}\\rfloorhigh(x)=⌊x/ ↓u​⌋ low(x)=x mod ↓ ⁣ ⁣ ⁣ ⁣ulow(x)=x\\bmod\\ ^\\downarrow\\!\\!\\!\\!\\sqrt{u}low(x)=xmod ↓u​ index(x,y)=x ↓ ⁣ ⁣ ⁣ ⁣u+yindex(x,y)=x\\ \\ ^\\downarrow\\!\\!\\!\\!\\sqrt{u}+yindex(x,y)=x ↓u​+y 4.14.14.1 结构 vEB 的结构是以 proto_vEB 为基础修改而来，我们称一个大小为 uuu 的 vEB 结构为 vEB(u)vEB(u)vEB(u)。由于 uuu 发生了变化，在非基础结构中，summarysummarysummary 指向一个 vEB( ↑ ⁣ ⁣ ⁣ ⁣u)vEB(\\ ^\\uparrow\\!\\!\\!\\!\\sqrt u)vEB( ↑u​) 结构，clusterclustercluster 数组则包含了 ↑ ⁣ ⁣ ⁣ ⁣u\\ ^\\uparrow\\!\\!\\!\\!\\sqrt u ↑u​ 个簇，每个簇都分别指向一个 vEB( ↓ ⁣ ⁣ ⁣ ⁣u)vEB(\\ ^\\downarrow\\!\\!\\!\\!\\sqrt{u})vEB( ↓u​) 结构。 除此之外，我们还新增了两个属性: min:min:min: 表示该结构内的最小元素。 max:max:max: 表示该结构内的最大元素。 如图就是一个 vEB 结构： 结构体和定义： map&lt;int,int&gt;lg; struct vEB{ int u,summary; vector&lt;int&gt;cluster; int min,max; }vEB[MAXN]; void init(){ for(int i=0;i&lt;32;++i)lg[1&lt;&lt;i]=i;//预处理log } inline int high(int p,int x){ int u=1&lt;&lt;(lg[vEB[p].u]&gt;&gt;1); return x/u; } inline int low(int p,int x){ int u=1&lt;&lt;(lg[vEB[p].u]&gt;&gt;1); return x%u; } inline int index(int p,int x,int y){ int u=1&lt;&lt;(lg[vEB[p].u]&gt;&gt;1); return x*u+y; } 特别地，我们有一些性质： minminmin 中存储的元素一定不会在该结构的所有簇中出现（maxmaxmax 不一定）。 如果是基础结构，那么我们不再需要用 AAA 数组，可以直接使用 minminmin 和 maxmaxmax 表示（如果只有一个元素，则 minminmin 和 maxmaxmax 都为它，如果没有元素的话，minminmin 和 maxmaxmax 都为 NILNILNIL）。 通过 minminmin 和 maxmaxmax,我们可以在常数时间内知道一个结构是否为空，或者仅含一个或两个以上的元素，可以缩短插入、删除、前驱、后继的递归调用链。 以下就是一棵标准的 vEB，其表示的集合跟之前 proto_vEB 的图一样，上述的性质均可在里面体现。 4.24.24.2 操作 下面我还是要给出一个递归式，根据《算法导论》给出解法，对于 vEB 的所有递归过程的操作的时间复杂度，我们都可以用下面的式子表示。 T(u)≤T( ↑ ⁣ ⁣ ⁣ ⁣u)+O(1)T(u)\\leq T(\\ ^\\uparrow\\!\\!\\!\\!\\sqrt u)+O(1) T(u)≤T( ↑u​)+O(1) 令 m=log⁡um=\\log um=logu，则有 T(2m)≤T(2⌈m2⌉)+O(1)T(2^m)\\leq T(2^{\\lceil\\frac{m}{2}\\rceil})+O(1) T(2m)≤T(2⌈2m​⌉)+O(1) 注意到，对于所有的 m≥2m\\geq2m≥2，都有 ⌈m2⌉≤2m3\\lceil\\frac{m}{2}\\rceil\\leq \\frac{2m}{3}⌈2m​⌉≤32m​，可以得到 T(2m)≤T(22m3)+O(1)T(2^m)\\leq T(2^{\\frac{2m}{3}})+O(1) T(2m)≤T(232m​)+O(1) 重命名 S(m)=T(2m)S(m)=T(2^m)S(m)=T(2m)，则重写为 S(m)≤S(2m3)+O(1)S(m)\\leq S(\\frac{2m}{3})+O(1) S(m)≤S(32m​)+O(1) 根据 master 定理，有解 S(m)=O(log⁡m)S(m)=O(\\log m)S(m)=O(logm)，所以我们有 T(u)=T(2m)=S(m)=O(log⁡m)=O(log⁡log⁡u)T(u)=T(2^m)=S(m)=O(\\log m)=O(\\log\\log u)T(u)=T(2m)=S(m)=O(logm)=O(loglogu) 4.2.14.2.14.2.1 判断某元素是否在集合中 bool Tree_Member(int p,int x){ if(x==vEB[p].min||x==vEB[p].max)return true; if(vEB[p].u==2)return false; return Tree_Member(vEB[p].cluster[high(p,x)],low(p,x)); } 第一句话就是缩短运行时间的，如果 xxx 是最大或最小值，直接返回。如果既不是最大值也不是最小值，且该结构还是基本结构的话，xxx 一定不存在（因为基本结构就这两种元素），否则还是递归。时间复杂度 O(log⁡log⁡u)O(\\log\\log u)O(loglogu)。 4.2.24.2.24.2.2 查询最大/小值 inline int Tree_Minimum(int p){ return vEB[p].min; } inline int Tree_Maximum(int p){ return vEB[p].max; } 这个不用说了吧，O(1)O(1)O(1) 解决。 4.2.34.2.34.2.3 查询后继 int Tree_Successor(int p,int x){ if(vEB[p].u==2){ if(x==0&amp;&amp;vEB[p].max==1)return 1; return NIL; } if(vEB[p].min!=NIL&amp;&amp;x&lt;vEB[p].min)return vEB[p].min; int offset,max_low=Tree_Maximum(vEB[p].cluster[high(p,x)]); if(max_low!=NIL&amp;&amp;low(p,x)&lt;max_low){ offset=Tree_Successor(vEB[p].cluster[high(p,x)],low(p,x)); return index(p,high(p,x),offset); } int succ_cluster=Tree_Successor(vEB[p].summary,high(p,x)); if(succ_cluster==NIL)return NIL; offset=Tree_Minimum(vEB[p].cluster[succ_cluster]); return index(p,succ_cluster,offset); } 判断基础结构的语句和原型一样。注意到，如果 xxx 严格小于结构内的最小值，则直接返回，这确实省了不少时间。如果这些情况都不满足，我们先判断 xxx 所在簇内是否有后继，可以查询簇内最大值 O(1)O(1)O(1) 确定，有的话直接确定位置然后返回，没有的话再继续查询 summarysummarysummary 内 xxx 所在簇是否有后继，有则返回该后继的最小值。 整个过程最多只会调用一次递归，原先查询簇内是否有后继和查询后继簇的最小值的 O(log⁡u)O(\\log u)O(logu) 步骤都用 O(1)O(1)O(1) 的最大/小值函数代替了，时间复杂度 O(log⁡log⁡u)O(\\log\\log u)O(loglogu)。 4.2.44.2.44.2.4 查询前驱 为什么前驱不和后继一起讲呢？因为前驱函数大体和后继函数是对称的，但是多加了一个判断： int Tree_Predecessor(int p,int x){ if(vEB[p].u==2){ if(x==1&amp;&amp;vEB[p].min==0)return 0; return NIL; } if(vEB[p].max!=NIL&amp;&amp;x&gt;vEB[p].max)return vEB[p].max; int offset,min_low=Tree_Minimum(vEB[p].cluster[high(p,x)]); if(min_low!=NIL&amp;&amp;low(p,x)&gt;min_low){ offset=Tree_Predecessor(vEB[p].cluster[high(p,x)],low(p,x)); return index(p,high(p,x),offset); } int pred_cluster=Tree_Predecessor(vEB[p].summary,high(p,x)); if(pred_cluster==NIL){ if(vEB[p].min!=NIL&amp;&amp;x&gt;vEB[p].min)return vEB[p].min; return NIL; } offset=Tree_Maximum(vEB[p].cluster[pred_cluster]); return index(p,pred_cluster,offset); } 这一句判断出现在第 131313 行： if(vEB[p].min!=NIL&amp;&amp;x&gt;vEB[p].min)return vEB[p].min; 还记得之前说到的性质吗，minminmin 中存在的元素不会出现在该结构的任何一个簇里，这里 pred_clusterpred\\_clusterpred_cluster 的值为 NILNILNIL，说明找不到前驱，但是还有一种可能，就是前驱就是 minminmin，这里就判断了这种情况。时间复杂度还是 O(log⁡log⁡u)O(\\log\\log u)O(loglogu)。 4.2.54.2.54.2.5 插入一个元素 在原型 vEB 里，插入需要两次递归：往簇里插入元素，将簇插入到 summarysummarysummary 中。我们来思考一下，怎么样才能只用一次递归呢？ 答案很简单，当该簇中有元素时，说明该簇已经存在于 summarysummarysummary 中，不需要再递归；当该簇为空时，我们直接把元素 O(1)O(1)O(1) 塞给 minminmin 和 maxmaxmax 就行，然后递归将这个簇插入到 summarysummarysummary 里面。这样就做到了只用一次递归。 inline void Empty_Tree_Insert(int p,int x){ vEB[p].max=vEB[p].min=x; } void Tree_Insert(int p,int x){ if(vEB[p].min==NIL){ Empty_Tree_Insert(p,x); return; } if(x&lt;vEB[p].min)swap(x,vEB[p].min); if(vEB[p].u&gt;2){ if(Tree_Minimum(vEB[p].cluster[high(p,x)])==NIL){ Tree_Insert(vEB[p].summary,high(p,x)); Empty_Tree_Insert(vEB[p].cluster[high(p,x)],low(p,x)); }else Tree_Insert(vEB[p].cluster[high(p,x)],low(p,x)); } if(x&gt;vEB[p].max)vEB[p].max=x; return; } 如果 minminmin 值为 NILNILNIL，则显然这个簇是没有任何元素的，直接 O(1)O(1)O(1)。同时我们要满足性质，如果插入的值比当前最小值还小，那么就交换一下就行了，因为 minminmin 不会出现在后面任何簇里，我们就改为插入之前的 minminmin 就行。接着就按照上面刚刚讲的来执行就行。最后还要判断一下有没有插入最大值。全程最多调用一次递归， O(log⁡log⁡u)O(\\log\\log u)O(loglogu)。 4.2.64.2.64.2.6 删除一个元素 所有操作里面最难理解的来了哦。 void Tree_Delete(int p,int x){//保证x存在于集合中 if(vEB[p].min==vEB[p].max){ vEB[p].min=vEB[p].max=NIL; return; } if(vEB[p].u==2){ vEB[p].max=vEB[p].min=!x; return; } if(x==vEB[p].min){ int first_cluster=Tree_Minimum(vEB[p].summary); x=index(p,first_cluster,Tree_Minimum(vEB[p].cluster[first_cluster])); vEB[p].min=x; } Tree_Delete(vEB[p].cluster[high(p,x)],low(p,x)); if(Tree_Minimum(vEB[p].cluster[high(p,x)])==NIL){ Tree_Delete(vEB[p].summary,high(p,x)); if(x==vEB[p].max){ int summary_max=Tree_Maximum(vEB[p].summary); if(summary_max==NIL)vEB[p].max=vEB[p].min;//如果summary里面为空，那么剩下的就只有min了（就算min的值为NIL也直接赋值给max） else vEB[p].max=index(p,summary_max,Tree_Maximum(vEB[p].cluster[summary_max]));//否则重新设置max } }else if(x==vEB[p].max)vEB[p].max=index(p,high(p,x),Tree_Maximum(vEB[p].cluster[high(p,x)])); return; } 首先确定结构内元素的个数，如果只有一个，像第一句判断一样，直接就删除了，否则结构内至少有两个元素。如果是基础结构(两个元素)，那么置 minminmin 和 maxmaxmax 为另外一个就行。接下来就是非基础结构的情况了。 首先考虑如果删除的是 minminmin，根据性质，我们只需要直接找到第二小的元素给他替换上就行。 然后我们递归删除簇内的这个元素，如果删掉后簇为空了，那么就从 summarysummarysummary 里面删掉这个簇。再来考虑删掉的是最大值的情况，我们只要找到第二大的替换上去就行。为什么调用最大值函数一定就是第二大呢？因为 xxx 既是簇里的最大值，又是簇里的唯一一个元素，删掉了它，又删掉了簇，剩下的不就是第二大了嘛，其余部分看注释。 如果删掉 xxx 后簇没空，再考虑删去的是最大值的情况，因为前面已经调用了删去 xxx 的函数，那么剩下的肯定是第二大，直接替换上去就行。 乍一看，删除函数里面最多会调用两次递归，但是注意调用的条件：我们调用第二次递归的前提是 xxx 是簇里唯一的元素，既然是唯一的，那么删除它的时候会在第一个判断的时候 O(1)O(1)O(1) 判断掉。所以只会有两种可能： 第一次调用只用 O(1)O(1)O(1)。 第二次调用不会发生。 所以删除操作的时间复杂度还是 O(log⁡log⁡u)O(\\log\\log u)O(loglogu) 的。 终于讲完啦！ 5.5.5. 例题 普通van Emde Boas树 O(log⁡log⁡u)O(\\log\\log u)O(loglogu) 的时间复杂度处理 10610^6106 的数据还是游刃有余的，但唯一的缺点就是建树的时间是 O(u)O(u)O(u) 的，如果操作过少，值域过大，效率可能比其它树数据结构还低。 Code:Code:Code: #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=2e6,NIL=-1; int cnt; map&lt;int,int&gt;lg; struct vEB{ int u,summary; vector&lt;int&gt;cluster; int min,max; }vEB[MAXN]; inline void Tree_Build(int p,int size){//u=2^size vEB[p].summary=vEB[p].min=vEB[p].max=NIL; if(size&lt;=1){ vEB[p].u=2;return; } vEB[p].u=1&lt;&lt;size; int cluster_size=(size&gt;&gt;1)+(size&amp;1);//即ceil(log(u)/2) vEB[p].summary=++cnt; Tree_Build(vEB[p].summary,cluster_size); vEB[p].cluster.resize(1&lt;&lt;cluster_size); //节省空间用的 for(int i=0;i&lt;1&lt;&lt;cluster_size;++i){ vEB[p].cluster[i]=++cnt; Tree_Build(vEB[p].cluster[i],size&gt;&gt;1); } return; } void init(){ for(int i=0;i&lt;32;++i)lg[1&lt;&lt;i]=i; } inline int high(int p,int x){ int u=1&lt;&lt;(lg[vEB[p].u]&gt;&gt;1); return x/u; } inline int low(int p,int x){ int u=1&lt;&lt;(lg[vEB[p].u]&gt;&gt;1); return x%u; } inline int index(int p,int x,int y){ int u=1&lt;&lt;(lg[vEB[p].u]&gt;&gt;1); return x*u+y; } inline int Tree_Minimum(int p){ return vEB[p].min; } inline int Tree_Maximum(int p){ return vEB[p].max; } bool Tree_Member(int p,int x){ if(x==vEB[p].min||x==vEB[p].max)return true; if(vEB[p].u==2)return false; return Tree_Member(vEB[p].cluster[high(p,x)],low(p,x)); } int Tree_Successor(int p,int x){ if(vEB[p].u==2){ if(x==0&amp;&amp;vEB[p].max==1)return 1; return NIL; } if(vEB[p].min!=NIL&amp;&amp;x&lt;vEB[p].min)return vEB[p].min; int offset,max_low=Tree_Maximum(vEB[p].cluster[high(p,x)]); if(max_low!=NIL&amp;&amp;low(p,x)&lt;max_low){ offset=Tree_Successor(vEB[p].cluster[high(p,x)],low(p,x)); return index(p,high(p,x),offset); } int succ_cluster=Tree_Successor(vEB[p].summary,high(p,x)); if(succ_cluster==NIL)return NIL; offset=Tree_Minimum(vEB[p].cluster[succ_cluster]); return index(p,succ_cluster,offset); } int Tree_Predecessor(int p,int x){ if(vEB[p].u==2){ if(x==1&amp;&amp;vEB[p].min==0)return 0; return NIL; } if(vEB[p].max!=NIL&amp;&amp;x&gt;vEB[p].max)return vEB[p].max; int offset,min_low=Tree_Minimum(vEB[p].cluster[high(p,x)]); if(min_low!=NIL&amp;&amp;low(p,x)&gt;min_low){ offset=Tree_Predecessor(vEB[p].cluster[high(p,x)],low(p,x)); return index(p,high(p,x),offset); } int pred_cluster=Tree_Predecessor(vEB[p].summary,high(p,x)); if(pred_cluster==NIL){ if(vEB[p].min!=NIL&amp;&amp;x&gt;vEB[p].min)return vEB[p].min; return NIL; } offset=Tree_Maximum(vEB[p].cluster[pred_cluster]); return index(p,pred_cluster,offset); } inline void Empty_Tree_Insert(int p,int x){ vEB[p].max=vEB[p].min=x; } void Tree_Insert(int p,int x){ if(vEB[p].min==NIL){ Empty_Tree_Insert(p,x); return; } if(x&lt;vEB[p].min)swap(x,vEB[p].min); if(vEB[p].u&gt;2){ if(Tree_Minimum(vEB[p].cluster[high(p,x)])==NIL){ Tree_Insert(vEB[p].summary,high(p,x)); Empty_Tree_Insert(vEB[p].cluster[high(p,x)],low(p,x)); }else Tree_Insert(vEB[p].cluster[high(p,x)],low(p,x)); } if(x&gt;vEB[p].max)vEB[p].max=x; return; } void Tree_Delete(int p,int x){ if(vEB[p].min==vEB[p].max){ vEB[p].min=vEB[p].max=NIL; return; } if(vEB[p].u==2){ vEB[p].max=vEB[p].min=!x; return; } if(x==vEB[p].min){ int first_cluster=Tree_Minimum(vEB[p].summary); x=index(p,first_cluster,Tree_Minimum(vEB[p].cluster[first_cluster])); vEB[p].min=x; } Tree_Delete(vEB[p].cluster[high(p,x)],low(p,x)); if(Tree_Minimum(vEB[p].cluster[high(p,x)])==NIL){ Tree_Delete(vEB[p].summary,high(p,x)); if(x==vEB[p].max){ int summary_max=Tree_Maximum(vEB[p].summary); if(summary_max==NIL)vEB[p].max=vEB[p].min; else vEB[p].max=index(p,summary_max,Tree_Maximum(vEB[p].cluster[summary_max])); } }else if(x==vEB[p].max)vEB[p].max=index(p,high(p,x),Tree_Maximum(vEB[p].cluster[high(p,x)])); return; } int n,m,rt; int main(){ init(); // freopen(&quot;std.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;my.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int u=0;for(--n;n;n&gt;&gt;=1,++u); Tree_Build(rt,u); while(m--){ int op,x;scanf(&quot;%d&quot;,&amp;op); if(op==1){ scanf(&quot;%d&quot;,&amp;x); if(!Tree_Member(rt,x))Tree_Insert(rt,x); }else if(op==2){ scanf(&quot;%d&quot;,&amp;x); if(Tree_Member(rt,x))Tree_Delete(rt,x); }else if(op==3){ printf(&quot;%d\\n&quot;,Tree_Minimum(rt)); }else if(op==4){ printf(&quot;%d\\n&quot;,Tree_Maximum(rt)); }else if(op==5){ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,Tree_Predecessor(rt,x)); }else if(op==6){ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,Tree_Successor(rt,x)); }else if(op==7){ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,Tree_Member(rt,x)?1:-1); } } return 0; } 后记 终于写完啦！！1，现在是 2021 年 6 月 27 日 23 时 39 分。 写这篇文章的原因不只是因为从《算法导论》里看到的，还有一个原因是之前在日报里看到过：Ynoi的学习笔记，只是很简单的讲了一下，但也激发了我很大的兴趣。vEB 树虽然实用性不强，但是能够很好的激发思维，这才是我写完这篇文章的动力。 谢谢观看。 ","link":"https://reqwq.github.io/post/ni-suo-bu-liao-jie-de-shu-ju-jie-gou-van-emde-boas-shu/"},{"title":"【置顶】关于我","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 这里保存着本人 OI 的学习笔记及做题记录等，欢迎浏览！ 👨‍💻 博主是谁 luogu：REqwq 欢迎访问我的主页并关注（划掉 ⛹ 兴趣爱好 OI，音游 ","link":"https://reqwq.github.io/post/about/"},{"title":"NOIP 游寄","content":"诶好，还没 AFO 呢，没 AFO 呢。 没想到我妈和班主还支持我继续 OI。 NOIP 这次是旅游场了属于是。 DAY -2 今天做核酸，约定时间等了半天医生还没来。 上班主的课的时候突然被狠夸了一顿，有点受宠若惊。 DAY -1 我又最晚到高铁站，真是应验了住的越近来的越晚定律。 上车第一件事就是颓废，之后做了一道题，看了一眼各种模板。 坐了3个多小时的高铁和地铁出来，仿佛到了一片郊区。 一路上跟着 jz 的神仙们走大街穿小巷，走了大概 1.6 km 才到酒店。 这环境比 csp 的好多了，贼宽敞，床贼软，我跟 my 神仙分到一房 /se/qq。 DAY 0 超早就起了，吃完酒店的低配版早餐之后跟着 jz 神们坐大巴去考场。 到了考场照例拍合照，面到了 zjy 神仙orz。 这次可以带水进了，好耶。 开始之后走流程，浏览了一遍题面之后觉得顺序开题。 T1 还是比较良心的，搞个筛直接草过三个样例。觉得人均 100pts T2 就开始离谱了，打了暴力之后想怎么优化，就这样想了 1h，还是去开 T3。 T3 很快就搞完了暴力，跟 T2 一样枚举所有的可能，结果样例 1 过了，2 居然过不了？？？ 之后就一直在 T2 和 T3 直接徘徊，T4 4s 的时限，觉得是大模拟就不理了。 然后就寄了 /kk/kk/kk/kk/kk/kk/kk 出来了，又是罚坐，估分 100+0+12+0 真的退役了。 这次文件解压的密码是 IronHeart... 钢铁之心，却如玻璃般易碎。 终焉。 接下来的时间，学学新东西，多打打比赛，不过还是 whk 为重吧。 高中见。 “纵使日薄西山，即使看不见未来，此时的光辉，盼君勿忘。” ","link":"https://reqwq.github.io/post/noip-you-ji/"},{"title":"CSP2021退役记","content":"Hello, OI !Hello,\\ OI \\,!Hello, OI! 自从开学起，whkwhkwhk 一直不断，两三个星期里，OIOIOI 的时间严重不足，甚至少到仅能看看文章，而没时间打代码，就在这样的情况下，CSPCSPCSP 到来了。 大约八月初的时候，收到了可以报名的信息，很快地提交了信息，并于月底准时给西西弗捐完钱，之后的日子就如我上面所说的一样。 Day 1:Day\\ 1:Day 1: 早上是 tgtgtg，我想着随便考，以我的能力还难以在 tgtgtg 组立足，抱着这样的心态，我来到了考场。 其他人来的很早，初三的还有几个初二的神仙。没一会就进考场了，走完一遍程序便开始发卷。 很好，前面的单选题做的还算得心应手，转到最恶心的读程序题。 计算几何，开幕雷击。我整个人傻掉了，凭感觉选了几个答案下去。第二题读了一下像是最大子序和，这道题做的还行，复杂度靠主定理轻松求得。第三道题，？？？字符串，我又傻掉了，再次乱选。考完才知道这是个叫 base64base64base64 的东西。 开始自闭，殊不知可怕的在后面。 魔法数字写起来还挺顺利的，第二题——四毛子？！神 tm 提高考这些？？？ 这玩意一周前我还看过，然而忘的一干二净。长叹一口气，又只好瞎蒙几个下去。 果然我还是不配待在 tgtgtg。中午对完答案只剩下 565656 分，岌岌可危。 相比之下，下午就显得轻松许多。单选题 20min20min20min 不到就做完了，转向读程序。 第一题一个很显然的 popcount+lowbitpopcount+lowbitpopcount+lowbit ，快速写完，甚至觉得轻松得有点诡异。 果然，我的预感是正确的，第二题，又 tm 出了 base64base64base64，虽然是弱化版的，但我还是不会啊！又只得蒙了几个。第三题一个像线性筛的东西，但是我记错复杂度了，也没看出他到底要求什么东西。 完善程序就很简单，可以说是送分。 出来感觉还行，想着 base64base64base64 和线性筛扣一点自己七八十应该稳了，可是我错了。 对完答案，我几乎崩溃，只有 68.568.568.5，base64base64base64 挂了大分，三道选择全错，线性筛也挂了很多。 晚上感觉很彷徨，原本的游记计划鸽掉了，whkwhkwhk 并颓废了一会冷静一下。后来 mymymy 来问我成绩 目前来说，我的 tgtgtg 可能擦线过，而 pjpjpj 悬了，未来能否进复赛，只能看天命了。 洛谷的膜你赛错过了，准备找个时间补一补题。 Day 1.5:Day\\ 1.5:Day 1.5: 噫！好了！我中了！ 害，一直都忘了更新游记。 Day 2:Day\\ 2:Day 2: 好极了，可以躲避 whk，还不用早起。 离高铁站最近，来的最晚/kel。 等高铁的时候，wt 哥哥居然在 whk ！！1 上车后，打了一下模板，主要还是颓废（ 然后就到了。 然后坐地铁。 然后出了地铁后，我们直接错过了酒店，跑到马路另一边，又跑了回来。 广州真是个充满多样性的城市。 好冷。 早上超早就起来了，跑去麦当劳结果七点才开门，草草在便利店解决完毕。 今年 pj 还行，没有离谱 dp，能打的都打了。 T1 签到题考场上想了大概 15min，脑子突然卡住了，在 30min 的时候搞完了。中午午睡的时候突然把我的做法 hack 了（居然三个样例都过了 /fad），希望 CCF 脚造数据良心亿点 /fad。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int n,l,r; int main(){ freopen(&quot;candy.in&quot;,&quot;r&quot;,stdin);freopen(&quot;candy.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;l,&amp;r); if(r-l&gt;=n)printf(&quot;%d&quot;,n-1); else printf(&quot;%d&quot;,r%n); fclose(stdin);fclose(stdout); return 0; } 。 T2 sort 一眼看到操作 1 数量不超过 5000，中间调了一些奇奇怪怪的错误，花了 1h 切掉。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N=8e3+10; int n,q,b[N]; struct node{ int val,id; }a[N]; inline bool cmp(node x,node y){return x.val==y.val?x.id&lt;y.id:x.val&lt;y.val;} int found(int v,int p){ int l=1,r=n,mid; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(a[mid].val==v){ if(a[mid].id==p)return mid; if(a[mid].id&gt;p)r=mid-1; else l=mid+1; }else if(a[mid].val&gt;v)r=mid-1; else l=mid+1; } return mid; } int main(){ freopen(&quot;sort.in&quot;,&quot;r&quot;,stdin);freopen(&quot;sort.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i].val),a[i].id=i,b[i]=a[i].val; sort(a+1,a+n+1,cmp); int op,x,y; while(q--){ scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op==1){ scanf(&quot;%d&quot;,&amp;y); if(b[x]==y)continue; int pos=found(b[x],x); if(b[x]&lt;y){ a[pos].val=b[x]=y; for(int i=pos;((a[i+1].val&lt;a[i].val)||(a[i+1].val==a[i].val&amp;&amp;a[i].id&gt;a[i+1].id))&amp;&amp;i&lt;n;++i)swap(a[i],a[i+1]); }else { a[pos].val=b[x]=y; for(int i=pos;((a[i-1].val&gt;a[i].val)||(a[i-1].val==a[i].val&amp;&amp;a[i].id&lt;a[i-1].id))&amp;&amp;i&gt;=2;--i)swap(a[i],a[i-1]); } }else printf(&quot;%d\\n&quot;,found(b[x],x)); } fclose(stdin);fclose(stdout); return 0; } T3 模拟还不会做，跳过。 T4 马上就想到链表，可惜调了半天没调出来，遂改成队列，总共花了接近 1.5h。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N=2e5+10; int n,a[N],cnt; queue&lt;int&gt;q[N]; int main(){ freopen(&quot;fruit.in&quot;,&quot;r&quot;,stdin);freopen(&quot;fruit.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); a[0]=2;cnt=0; for(int i=1;i&lt;=n;++i){ if(a[i]!=a[i-1])q[++cnt].push(i); else q[cnt].push(i); } bool fl=true; while(fl){ int lst=0;fl=false; for(int i=1;i&lt;=cnt;++i){ if(q[i].empty())continue; int x=q[i].front(); if(a[x]==a[lst])continue; printf(&quot;%d &quot;,x);q[i].pop(); fl=true; lst=x; } if(fl)printf(&quot;\\n&quot;); } fclose(stdin);fclose(stdout); return 0; } T3 只剩差不多半小时了，只好抓几个性质骗个分。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N=1e3+10; int n,op[N],a[N],b[N],c[N],d[N],e[N]; bool vis[N]; char s[10]; int main(){ freopen(&quot;network.in&quot;,&quot;r&quot;,stdin);freopen(&quot;network.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i){ scanf(&quot;%s&quot;,s);vis[i]=1;getchar(); op[i]=(s[0]=='S')?1:0; scanf(&quot;%d.%d.%d.%d:%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i],&amp;e[i]); if(a[i]&gt;255||b[i]&gt;255||c[i]&gt;255||d[i]&gt;255||e[i]&gt;65535){ printf(&quot;ERR\\n&quot;);vis[i]=0; continue; } if(op[i]==1){ bool fl=true; for(int j=1;j&lt;i;++j){ if(op[j]==0||!vis[j])continue; if(a[j]==a[i]&amp;&amp;b[j]==b[i]&amp;&amp;c[j]==c[i]&amp;&amp;d[j]==d[i]&amp;&amp;e[j]==e[i]){ fl=false;vis[i]=0; break; } } if(!fl)printf(&quot;FAIL\\n&quot;); else printf(&quot;OK\\n&quot;); }else { int pos=0; for(int j=1;j&lt;i;++j){ if(op[j]==0||!vis[j])continue; if(a[j]==a[i]&amp;&amp;b[j]==b[i]&amp;&amp;c[j]==c[i]&amp;&amp;d[j]==d[i]&amp;&amp;e[j]==e[i]){ pos=j; break; } } if(!pos)printf(&quot;FAIL\\n&quot;); else printf(&quot;%d\\n&quot;,pos); } } fclose(stdin);fclose(stdout); return 0; } 匆匆忙忙就搞完了，临近结束时突然冷得一批，全身都在抖。 luogu 估分：100+100+65+70=335 计蒜氪 估分：90+100+65+100=355 中午慌忙干完了饭，睡了 20min 又起来了，简直睡了个寂寞，tg 考场上困的要死，只会 t1 和 t3 暴力，其他交了个随机数就在那罚坐了 4h。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int N=1e5+10; int n,m1,m2; struct node { int id,x,y; } a[N]; priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q1,q2; bool cmp(node a,node b) { return a.x&lt;b.x; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m1,&amp;m2); if(n&gt;=m1+m2)printf(&quot;%d\\n&quot;,m1+m2); else { for(int i=1; i&lt;=m1+m2; ++i)scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y),a[i].id=(i&lt;=m1)?1:2; sort(a+1,a+m1+m2+1,cmp); int ans=0; for(int k=1; k&lt;=n; ++k) { int cur=0,cnt1=0,cnt2=0; while(!q1.empty())q1.pop(); while(!q2.empty())q2.pop(); for(int i=1; i&lt;=m1+m2; ++i) { if(a[i].id==1) { if(!q1.empty()&amp;&amp;a[i].x&gt;=q1.top())q1.pop(),q1.push(a[i].y),++cur; else if(cnt1&lt;k)q1.push(a[i].y),++cur,++cnt1; } else { if(!q2.empty()&amp;&amp;a[i].x&gt;=q2.top())q2.pop(),q2.push(a[i].y),++cur; else if(cnt2&lt;n-k)q2.push(a[i].y),++cur,++cnt2; } } ans=max(ans,cur); if(ans==m1+m2)break; } printf(&quot;%d\\n&quot;,ans); } return 0; } //T3 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int N=5e5+10; int t,n; bool fl; deque&lt;int&gt;q; struct node { int id,val; } a[N]; void dfs(int x) { if(x&gt;n*2) { fl=true; return; } if(x&lt;=n) { int now=q.front(); a[x].val=now; a[x].id=1; q.pop_front(); dfs(x+1); if(fl)return; q.push_front(now); now=q.back(); a[x].val=now; a[x].id=2; q.pop_back(); dfs(x+1); if(fl)return; a[x].val=a[x].id=0; q.push_back(now); } else { int now; if(q.front()==a[n*2-x+1].val) { now=q.front(); a[x].val=now; a[x].id=1; q.pop_front(); dfs(x+1); if(fl)return; q.push_front(now); a[x].val=a[x].id=0; } if(q.back()==a[n*2-x+1].val) { now=q.back(); a[x].val=now; a[x].id=2; q.pop_back(); dfs(x+1); if(fl)return; q.push_back(now); a[x].val=a[x].id=0; } } } int main() { scanf(&quot;%d&quot;,&amp;t); while(t--) { scanf(&quot;%d&quot;,&amp;n); if(n&lt;=10) { while(!q.empty())q.pop_back(); for(int i=1,x; i&lt;=n*2; ++i)scanf(&quot;%d&quot;,&amp;x),q.push_back(x); fl=false; dfs(1); if(fl) { for(int i=1; i&lt;=n*2; ++i)printf(&quot;%c&quot;,a[i].id==1?'L':'R'); printf(&quot;\\n&quot;); } else printf(&quot;-1\\n&quot;); } else printf(&quot;-1\\n&quot;); } return 0; } luogu 估分：40+0+28+0=68 希望真正成绩出来了不要锅吧。 听说 lsz 和 hkf 都炸掉，希望再接再厉，明年双报。 说来说去，也到了尾声，两年多的时间就这样过去了，希望我最终能交出一份满意的答卷吧。至此，正式进入文化课模式，明年见。 2147483648\\color{Black}21474836482147483648 长风破浪会有时，直挂云帆济沧海。 后记 突然收到信息说出分了，赶忙去查了一下。 PJ:70+100+65+80=315 不出意料 T1 假做法果然挂了分。 TG:50+0+44+0=94 出乎意料，比估分高，骗分很给力 OVER ","link":"https://reqwq.github.io/post/csp2021-tui-yi-ji/"},{"title":"GDOI游记","content":"多好啊，多好啊，不用 whkwhkwhk 的日子是多么美妙啊！ Day -2: 日常机房颓废，xgfxgfxgf 巨佬爆切树剖；可怜的蒟蒻 xrcxrcxrc 一道搜索一个中午都调不出；卷王 mymymy 和 wtwtwt 又去whk了/jk，真是太可怕了。 Ms.LiMs. LiMs.Li 说 GDOI 要做核酸。很快啊，啪的一下，立马就请了下午的自习。 btw，做核酸感觉没有想象中那么让人想yue，可能是那个医生太温柔了吧（ Day 0: 终于坐上车啦，神犇 wtwtwt 居然一上车就whk/jk，巨佬 xgfxgfxgf 爆切一堆模板/jk/jk/jk 无奈本蒟蒻太菜，只填了一点笔记坑/kk 几经周折，终于来了深圳，一路上被当猴子看（ 到了宿舍，左看右看，只看出了两个字：差评！！！！！！！1 整个宿舍三个插座，两个没电！唯一的一个还tm是三头的 只能靠着楼道里的插排过日子了/fn 花了 800800800 住了一个啥都没有的宿舍 万恶的资本主义啊 附：蚊子好多啊艹！！1 Day 1: 大早起来收到了住深圳的亲戚的空投：mainmainmain包、充电宝、花露水，就很nice。 早上的讲座讲的是搜索和 DP，笑死，根本听不懂。由于昨晚没睡好，全程昏昏欲睡，直到讲到数位 DP—— “这题你们明天一道题的弱化版。” ???????????? 赶紧录啊！！！！！！！！！1 然鹅中午干完饭回去研究了许久并没有理解。 下午早早地被宿管轰了出去，说是要帮我们打扫卫生，然后让我们整理好被子东西不能放床上然后把垃圾扔了？？？？？？？？无语 然后一群人挤在考场外的楼道里等了半个多小时。 终于开始了，先来看 T1: 第一眼：博弈论？？？ 当然这显然是一道结论题，然后sb的我一直想着异或，最后只会 10pts10pts10pts 部分分。当事人表示很后悔，自己部分分都推出来了，居然还看不出正解。赛后又得知这题人均 100pts100pts100pts。 再来T2: ？？？excrt？？? 笑死了，完全没学过好吧。然后蒟蒻连暴力都不会打，直接输出 &quot;ERROR&quot;。 应该是一道判环，但是 但是 我忘了啊啊啊 最后打了个假的判环走了，样例还有手摸的数据是能过的，只能看 rprprp 了。 最终得分：20+20+20=60。 苍天有眼啊，T1居然还多10，T2全ERROR有20。 回去干饭的时候，心态有点崩。 my &amp; xgf:my\\ \\&amp; \\ xgf:my &amp; xgf: “好简单啊这场” 回到宿舍继续颓废，mymymy 巨佬还在认真学习数位 DP。晚上长记性了，拉上了蚊帐，还喷了花露水，一晚上睡得极好，本来定了闹钟要和 gfgfgf 姐姐一起打 CF 比赛的，最后还是按掉了，显然 gfgfgf 姐姐也睡得很好。 Day 2: 话说这食堂的饭菜超油腻的，窝不怎么敢吃（怕拉肚子），只好就着几乎只有汤水的粥干完了昨天剩的 mainmainmain包。 讲座讲的是贪心，讲得挺棒的（至少比昨天的良心多了）。 臭死了/xyx 终于等到下午的比赛，结果比赛刚开始就出问题了：PDF打不开，只好都出来等。 “艹我们还要赶车啊，不会回不去了吧” 还好 15min15min15min 后解决了问题，重新进场。 T1: 看来是道裸的 kmpkmpkmp，结果考场上没调出来，只好打了暴力。 T2: /jk，数位DP，果断跳过（话说当初窝怎么没有想起输出样例啊艹） T3: emm，考场上打了个双向链表，具体思路是这样的：如果我打不过我旁边的，就看看他旁边的人能不能打得过他，再看我打不打得过那个人。但是做法是假的，第三个样例总是过不去，最后也没调出来。 应 mymymy 哥哥的要求粘了代码： #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int N=1e5+10; int n,m,a[N],pre[N],nxt[N],num,pos[N]; inline bool fight(int x,int y){ if(a[x]==a[y])return true; register int tmp=(a[x]-a[y]+m)%m; return (tmp&gt;0&amp;&amp;tmp&lt;=(m&gt;&gt;1)); } bool check(int i){ int pr=pre[i],nx=nxt[i],x,y; while(pr^i&amp;&amp;nx^i){ if(fight(i,pr)){ pr=pre[pr]; }else if(fight(pre[pr],pr)){ pr=pre[pr]; }else return 0; if(fight(i,nx)){ nx=nxt[nx]; }else if(fight(nxt[nx],nx)){ nx=nxt[nx]; }else return false; } return true; } int main(){ freopen(&quot;game.in&quot;,&quot;r&quot;,stdin);freopen(&quot;game.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]),pre[i]=i-1,nxt[i]=i+1; pre[1]=n;nxt[n]=1; for(int i=1;i&lt;=n;++i){ if(check(i))pos[++num]=i; } printf(&quot;%d\\n&quot;,num); for(int i=1;i&lt;=num;++i)printf(&quot;%d &quot;,pos[i]); fclose(stdin);fclose(stdout); return 0; } 最终得分:30+0+30=60 还行，终于结束了，一结束几乎是跑着去赶高铁的，幸好最后赶上了。 慷慨的 Ms.LiMs.LiMs.Li 给我们带了麦当劳在车上吃。 终于结束了。 路上收到了周末各种培优班加强班的练习文件，抓紧赶完了一些作业。 终于结束了。 whkwhkwhk，你好。 后记： 现在是2021年4月24日21点51分，我躺在床上敲完了这篇游记，由于 whkwhkwhk 的原因这篇游记咕了两个星期。 期中考炸了，whkwhkwhk 越来越紧张，OIOIOI 不知还能不能继续下去。学 OIOIOI 已经有一年多了，但还是那么菜。当然，前途还远着呢，我还有很多时间。我也要珍惜这最后的时间，继续努力。 加油 ","link":"https://reqwq.github.io/post/gdoi-you-ji/"}]}